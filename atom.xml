<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>IT那些事儿</title>
  
  <subtitle>一个程序猿的进化史</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.astudyer.com/"/>
  <updated>2021-04-12T09:37:58.096Z</updated>
  <id>http://blog.astudyer.com/</id>
  
  <author>
    <name>匿名</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mac安装Homebrew</title>
    <link href="http://blog.astudyer.com/%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7/Mac%E5%AE%89%E8%A3%85Homebrew.html"/>
    <id>http://blog.astudyer.com/工具/工具/Mac安装Homebrew.html</id>
    <published>2021-04-12T09:11:54.000Z</published>
    <updated>2021-04-12T09:37:58.096Z</updated>
    
    <content type="html"><![CDATA[<h2 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h2><p><a href="https://brew.sh" target="_blank" rel="noopener">https://brew.sh</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)</span>"</span></span><br></pre></td></tr></table></figure><h2 id="其他安装方法"><a href="#其他安装方法" class="headerlink" title="其他安装方法"></a>其他安装方法</h2><p>由于国内的网络环境等问题，使用官方的安装方法可能无法安装成功。可以尝试使用其他更适合国内网络环境的安装方法，参考地址：<a href="https://brew.idayer.com/。" target="_blank" rel="noopener">https://brew.idayer.com/。</a></p><h2 id="安装homebrew-core"><a href="#安装homebrew-core" class="headerlink" title="安装homebrew-core"></a>安装homebrew-core</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c <span class="string">"<span class="variable">$(curl -fsSL https://cdn.jsdelivr.net/gh/ineo6/homebrew-install/install.sh)</span>"</span></span><br></pre></td></tr></table></figure><h2 id="安装homebrew-cask"><a href="#安装homebrew-cask" class="headerlink" title="安装homebrew-cask"></a>安装homebrew-cask</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="string">"<span class="variable">$(brew --repo)</span>/Library/Taps/homebrew/"</span></span><br><span class="line"> </span><br><span class="line">git <span class="built_in">clone</span> https://mirrors.ustc.edu.cn/homebrew-cask.git</span><br></pre></td></tr></table></figure><h2 id="源"><a href="#源" class="headerlink" title="源"></a>源</h2><p>为了加速以后使用Homebrew安装其他软件的过程，建议设置软件源为国内源。</p><h3 id="查看源"><a href="#查看源" class="headerlink" title="查看源"></a>查看源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="string">"<span class="variable">$(brew --repo)</span>"</span> &amp;&amp; git remote -v</span><br><span class="line"> </span><br><span class="line"><span class="built_in">cd</span> <span class="string">"<span class="variable">$(brew --repo homebrew/core)</span>"</span> &amp;&amp; git remote -v</span><br><span class="line"> </span><br><span class="line"><span class="built_in">cd</span> <span class="string">"<span class="variable">$(brew --repo homebrew/cask)</span>"</span> &amp;&amp; git remote -v</span><br></pre></td></tr></table></figure><h3 id="设置源"><a href="#设置源" class="headerlink" title="设置源"></a>设置源</h3><p>设置为中科大的源<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git -C <span class="string">"<span class="variable">$(brew --repo)</span>"</span> remote <span class="built_in">set</span>-url origin https://mirrors.ustc.edu.cn/brew.git</span><br><span class="line"> </span><br><span class="line">git -C <span class="string">"<span class="variable">$(brew --repo homebrew/core)</span>"</span> remote <span class="built_in">set</span>-url origin https://mirrors.ustc.edu.cn/homebrew-core.git</span><br><span class="line"> </span><br><span class="line">git -C <span class="string">"<span class="variable">$(brew --repo homebrew/cask)</span>"</span> remote <span class="built_in">set</span>-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git</span><br><span class="line"> </span><br><span class="line">brew update</span><br></pre></td></tr></table></figure></p><h3 id="设置bottles镜像"><a href="#设置bottles镜像" class="headerlink" title="设置bottles镜像"></a>设置bottles镜像</h3><p>从macOS Catalina(10.15.x) 版开始，Mac使用zsh作为默认shell，使用的配置文件：<code>.zprofile</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles'</span> &gt;&gt; ~/.zprofile</span><br><span class="line"> </span><br><span class="line"><span class="built_in">source</span> ~/.zprofile</span><br></pre></td></tr></table></figure></p><p>如果是以前的macOS版本，Mac使用bash作为默认shell，使用的配置文件：<code>.bash_profile</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles'</span> &gt;&gt; ~/.bash_profile</span><br><span class="line"> </span><br><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure></p><h3 id="重置为官方源"><a href="#重置为官方源" class="headerlink" title="重置为官方源"></a>重置为官方源</h3><p>可以通过以下命令还原回官方源。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">git -C <span class="string">"<span class="variable">$(brew --repo)</span>"</span> remote <span class="built_in">set</span>-url origin https://github.com/Homebrew/brew.git</span><br><span class="line"> </span><br><span class="line">git -C <span class="string">"<span class="variable">$(brew --repo homebrew/core)</span>"</span> remote <span class="built_in">set</span>-url origin https://github.com/Homebrew/homebrew-core.git</span><br><span class="line"> </span><br><span class="line">git -C <span class="string">"<span class="variable">$(brew --repo homebrew/cask)</span>"</span> remote <span class="built_in">set</span>-url origin https://github.com/Homebrew/homebrew-cask.git</span><br><span class="line"> </span><br><span class="line"><span class="comment"># zsh 注释掉 HOMEBREW_BOTTLE_DOMAIN 配置</span></span><br><span class="line">vi ~/.zprofile</span><br><span class="line"><span class="comment"># export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles</span></span><br><span class="line"><span class="built_in">source</span> ~/.zprofile</span><br><span class="line"> </span><br><span class="line"><span class="comment"># bash 注释掉 HOMEBREW_BOTTLE_DOMAIN 配置</span></span><br><span class="line">vi ~/.bash_profile</span><br><span class="line"><span class="comment"># export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles</span></span><br><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br><span class="line"> </span><br><span class="line">brew update</span><br></pre></td></tr></table></figure></p><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e <span class="string">"<span class="variable">$(curl -fsSL https://cdn.jsdelivr.net/gh/ineo6/homebrew-install/uninstall)</span>"</span></span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>[1] <a href="https://www.cnblogs.com/mjios/p/14497925.html" target="_blank" rel="noopener">Mac安装Homebrew</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;官网&quot;&gt;&lt;a href=&quot;#官网&quot; class=&quot;headerlink&quot; title=&quot;官网&quot;&gt;&lt;/a&gt;官网&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://brew.sh&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://brew.
      
    
    </summary>
    
      <category term="工具" scheme="http://blog.astudyer.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="brew" scheme="http://blog.astudyer.com/tags/brew/"/>
    
      <category term="homebrew" scheme="http://blog.astudyer.com/tags/homebrew/"/>
    
      <category term="mac" scheme="http://blog.astudyer.com/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>[译] Instruments 入门教程</title>
    <link href="http://blog.astudyer.com/%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7/%E8%AF%91-Instruments-%E6%95%99%E7%A8%8B-%E5%85%A5%E9%97%A8.html"/>
    <id>http://blog.astudyer.com/工具/工具/译-Instruments-教程-入门.html</id>
    <published>2020-09-15T07:48:53.000Z</published>
    <updated>2021-04-12T09:37:26.625Z</updated>
    
    <content type="html"><![CDATA[<p>了解如何使用 Instruments 来捕获和修复应用程序中的内存问题和性能错误，以使其更快，响应速度更快。</p><p>Version：Swift 5, iOS 13, Xcode 11</p><p>除了通过添加功能来改进其应用程序外，所有优秀的应用程序开发人员还应该做一件事：编写代码！</p><p>本教程将向您展示如何使用 Xcode 随附的 Instruments 工具的最重要功能。它使您可以检查代码中是否存在性能问题，内存问题，参考周期和其他问题。</p><p>可以了，好了？准备好进入迷人的 Instruments 世界！</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>对于本教程，您将不会经历从头开始创建应用的过程。相反，下载资料包括一个完整的示例项目。您的任务是像使用自己的应用程序一样，以 Instruments 为指导来浏览并改进该应用程序！</p><p>使用本教程底部的 <strong>“下载材料”</strong> 按钮下载项目材料。在 Xcode 中打开启动项目。</p><p>此示例应用程序使用 <strong>Flickr API</strong> 搜索图像。要使用 API​​，您需要一个 API 密钥。对于演示项目，您可以在 Flickr 的网站上生成示例密钥。只需在 <a href="http://www.flickr.com/services/api/explore/?method=flickr.photos.search" target="_blank" rel="noopener">Flickr API Explorer</a> 中执行任何搜索，然后从底部的 URL 复制 API 密钥即可。它一直沿 “＆api_key =” 到下一个 “＆”。</p><p>例如，如果URL为：<br><code>HTTP：//api.flickr.com/services/rest/?method=flickr.photos.search＆api_key = ff417a50b95180cb0c7e3b68a8749fba＆format = rest＆api_sig = f24f4e98063a9b8ecc8b522b238d5e2f</code></p><p>然后，API 密钥为：ff417a50b95180cb0c7e3b68a8749fba。</p><p>打开 <strong>FlickrAPI.swift</strong> 并将现有的 API 密钥值替换为新值。</p><p>请注意，API 密钥每天都会更改，因此有时您不得不重新生成一个新密钥。只要密钥无效，该应用程序就会提醒您。</p><p>生成并运行，执行搜索，单击结果，您将看到类似以下内容：<br><img src="http://image.astudyer.com/16001702844764.jpg" alt="-w258"><br>使用该应用程序并查看其基本功能。您可能会认为，一旦 UI 看起来不错，该应用就可以提交商店了。但是，您将看到使用 Instruments 可以为您的应用添加的价值。</p><p>本教程的其余部分将向您展示如何查找和修复应用程序中仍然存在的问题。您将看到 Instruments 如何使调试问题大为简化！</p><h2 id="Time-Profiler"><a href="#Time-Profiler" class="headerlink" title="Time Profiler"></a>Time Profiler</h2><p><img src="http://image.astudyer.com/16001702844792.jpg" alt="-w80"><br>您将要看的第一个乐器是 <strong>Time Profiler</strong>。每隔一定的时间间隔，Instruments 将暂停程序的执行，并在每个运行的线程上进行堆栈跟踪。可以将其视为单击 Xco​​de 调试器中的“暂停”按钮。</p><p>这是 Time Profiler 的预览：<br><img src="http://image.astudyer.com/16001702844804.jpg" alt="-w889"><br>此界面显示 <strong>Call Tree</strong>。Call Tree 显示了在应用程序中执行各种方法所花费的时间。每一行都是程序执行路径遵循的不同方法。Instruments 通过计算分析器在每种方法中停止的次数来估算每种方法所花费的时间。</p><p>例如，如果您以1毫秒的间隔进行100个采样，并且在10个采样中的某个特殊方法出现在堆栈的顶部，则可以推断出该方法花费了该应用大约10％的总执行时间（10毫秒）。这是一个很粗略的近似值，但是可以用！</p><blockquote><p>注意：通常，您应该始终在实际设备上而不是模拟器上对应用程序进行配置文件配置。iOS 模拟器具有Mac 的全部功能，而设备将具有移动硬件的所有限制。您的应用似乎可以在模拟器中正常运行，但是一旦它在真实设备上运行，您可能会发现性能问题。</p></blockquote><p>因此，事不宜迟，该花些时间进行检测了！</p><h2 id="仪器仪表"><a href="#仪器仪表" class="headerlink" title="仪器仪表"></a>仪器仪表</h2><p>在 Xcode 的菜单栏中，选择 <strong>Product ▸ Profile</strong> 或按 <strong>Command-I</strong>。这将构建应用程序并启动 Instruments。您将看到一个选择窗口，如下所示：<br><img src="http://image.astudyer.com/16001702844815.jpg" alt="-w626"><br>这些是Instruments随附的所有不同模板。</p><p>选择Time Profiler仪器，然后单击选择。这将打开一个新的Instruments文档。单击左上角的红色录制按钮开始录制并启动该应用程序。macOS可能会要求您输入密码以授权Instruments分析其他进程。别担心，可以在这里安全地提供！</p><p>在“工具”窗口中，您可以看到时间在向上计数，并且在屏幕中心的图形上方有一个小箭头从左向右移动。这表明该应用程序正在运行。</p><p>现在，开始使用该应用程序。搜索一些图像，然后向下钻取一个或多个搜索结果。您可能已经注意到，进入搜索结果的过程非常缓慢，并且滚动浏览搜索结果列表也非常令人讨厌。这是一个非常笨拙的应用程序！</p><p>好吧，你很幸运。您即将着手修复它！但是，您首先要快速了解 Instruments 中的内容。</p><p>首先，确保工具栏右侧的视图选择器同时选择了两个选项，如下所示：<br><img src="http://image.astudyer.com/16001702844824.jpg" alt="-w147"><br>这样可以确保所有面板均打开。现在，研究下面的屏幕截图以及下面每个部分的说明：<br><img src="http://image.astudyer.com/16001702844834.jpg" alt="-w648"></p><ol><li><strong>录制控件</strong>：红色的“录制”按钮停止并启动当前正在测试的应用。暂停按钮可暂停应用程序的当前执行。</li><li><strong>运行计时器</strong>：计时器计算已配置应用程序已运行了多长时间以及已运行了多少次。单击停止按钮，然后重新启动应用程序。您将看到显示为 <strong>Run 2 of 2</strong> 的显示。</li><li><strong>乐器音轨</strong>：对于您选择的 Time Profiler 模板，只有一架乐器，因此只有一条音轨。您将在本教程的后面部分中详细了解该图的细节。</li><li><p><strong>详细信息面板</strong>：显示有关您正在使用的特定乐器的主要信息。在这种情况下，它显示了“最热”的方法，即使用最多CPU时间的方法。</p><p> 在详细信息面板的顶部，单击 <strong>Profile</strong>，然后选择样本。在这里您可以查看每个样本。点击一些样本；您将看到捕获的堆栈跟踪显示在右侧的扩展详细信息检查器中。完成后，切换回个人资料。</p></li><li>检查器面板：有两个检查器- <strong>Extended Detail</strong> 和 <strong>Run Info</strong> -您将很快了解更多信息。</li></ol><h2 id="深钻"><a href="#深钻" class="headerlink" title="深钻"></a>深钻</h2><p>执行图像搜索，然后深入研究结果。我个人喜欢搜索“狗”，但是选择任何您想要的-您可能就是其中的猫人之一！</p><p>现在，上下滚动列表几次，以便在 Time Profiler 中获得大量数据。您应该注意到屏幕中间的数字在变化，并且图形在填充。这表明您的应用程序正在使用CPU周期。</p><p>直到滚动像黄油一样，任何收藏视图都无法交付！</p><p>为了帮助查明问题，您将设置一些选项。单击 <strong>Stop</strong>，然后在详细信息面板下方，单击 <strong>Call Tree</strong>。在出现的弹出窗口中，选择 <strong>Separate by Thread</strong>，<strong>Invert Call Tree</strong> 和 <strong>Hide System Libraries</strong>。它看起来像这样：<br><img src="http://image.astudyer.com/16001702844843.jpg" alt="-w469"><br>以下是每个选项对左侧表格中显示的数据的处理方式：</p><ul><li><strong>Separate by State</strong>：此选项按应用程序的生命周期状态对结果进行分组，是一种检查应用程序正在执行的工作量和时间的有用方法。</li><li><strong>Separate by Thread</strong>：分别对待每个线程。这使您能够了解哪些线程导致最大的 CPU 使用量。</li><li><strong>Invert Call Tree</strong>：使用此选项，堆栈跟踪将首先显示最近的帧。</li><li><strong>Hide System Libraries</strong>：选择此选项时，仅显示您自己的应用程序中的符号。选择此选项通常很有用，因为通常您只关心 CPU 在自己的代码中花费的时间，而对于系统库使用的 CPU 数量却做得不多！</li><li><strong>Flatten Recursion</strong>：此选项显示递归函数，这些函数可以在每个堆栈跟踪中只有一个条目，而不是多次调用自己。</li><li><strong>Top Functions</strong>：启用此功能可使仪器将在一个功能上花费的总时间视为该功能内直接花费的时间之和，以及该功能所调用的功能所花费的时间。因此，如果函数A 调用B ，则 Instruments 将A的时间报告为A所花费的时间加上B中所花费的时间。这非常有用，因为它使您每次下降到调用堆栈时都选择最大的时间数字，将其清零使用最耗​​时的方法。</li></ul><p>扫描结果以识别 <strong>Weight</strong> 列中哪些行具有最高百分比。请注意，带有 <strong>Main Thread</strong> 的行正在消耗大量的 CPU 周期。通过单击文本左侧的小箭头来展开该行，然后向下钻取，直到看到您自己的方法之一，并标有“人”符号。尽管某些值可能会略有不同，但是条目的顺序应类似于下表：<br><img src="http://image.astudyer.com/16001702844853.jpg" alt="-w708"><br>好吧，那看起来当然不好。该应用程序将大部分时间用于将 <strong>“tonal”</strong> 滤镜应用于缩略图的方法。这对您来说应该不会太震惊，因为表格的加载和滚动是 UI 中最笨拙的部分，并且表格单元会不断更新。</p><p>要了解有关该方法中发生的事情的更多信息，请双击表中的该行。这样做将显示以下视图：<br><img src="http://image.astudyer.com/16001702844863.jpg" alt="-w635"><br><code>applyTonalFilter()</code> 是 <code>UIImage</code> 扩展中添加的方法，并且 <code>CGImage</code> 在应用图像滤镜之后花费大量时间调用创建输出的方法。</p><p>您实际上没有什么可以做来加快速度。创建映像是一个密集的过程，需要花费很长时间。尝试后退以查看应用程序的调用位置 <code>applyTonalFilter()</code>。在代码视图顶部的面包屑路径中单击 <strong>Root</strong> 以返回上一屏幕：<br><img src="http://image.astudyer.com/16001702844872.jpg" alt="-w473"><br>现在，单击 <code>applyTonalFilter</code> 表顶部行左侧的小箭头。这将显示呼叫者 <code>applyTonalFilter</code>-您可能也需要展开下一行。在对 Swift 进行性能分析时，有时会在 <strong>Call Tree</strong> 中有重复的行，并带有 <code>@objc</code>。您对第一行带有“人”图标的前缀感兴趣，这表明它属于您应用的目标：<br><img src="http://image.astudyer.com/16001702844882.jpg" alt="-w586"><br>在这种情况下，该行引用结果收集视图的 <code>(_:cellForItemAt:)</code>。双击该行以查看项目中的关联代码。</p><p>现在您可以看到问题所在了。看一下第70行：应用 <code>tonal filter</code> 的方法要花很长时间才能执行，您可以直接从调用它 <code>collectionView(_:cellForItemAt:)</code>。这将在每次请求过滤图像时阻塞主线程，并因此阻塞整个UI。</p><h2 id="分担工作"><a href="#分担工作" class="headerlink" title="分担工作"></a>分担工作</h2><p>要解决此问题，您将采取两个步骤：首先，将图像过滤的方法放到后台线程上 <code>DispatchQueue.global().async</code>。然后，在生成每个图像后对其进行缓存。<code>ImageCache</code> 入门项目中包含一个小型，简单的图像缓存类-具有易记的名称，该类仅将图像存储在内存中并使用给定的键检索它们。</p><p>现在，您可以切换到 Xcode，并在 Instruments 中手动找到要查看的源文件。但是，在Instruments 中有一个方便的 <strong>Open in Xcode</strong> 按钮。在代码上方的面板中找到它，然后单击它：<br><img src="http://image.astudyer.com/16001702844895.jpg" alt="-w1782"><br>太棒了！Xcode刚好在正确的位置打开！</p><p>现在，将 <code>collectionView(_:cellForItemAt:)</code> 中的 <code>loadThumbnail(for:completion:)</code> 方法替换为以下内容：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ImageCache</span>.shared.loadThumbnail(<span class="keyword">for</span>: flickrPhoto) &#123; result <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">switch</span> result &#123;</span><br><span class="line">  <span class="keyword">case</span> .success(<span class="keyword">let</span> image):</span><br><span class="line">    <span class="keyword">if</span> cell.flickrPhoto == flickrPhoto &#123;</span><br><span class="line">      <span class="keyword">if</span> flickrPhoto.isFavourite &#123;</span><br><span class="line">        cell.imageView.image = image</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> cachedImage = </span><br><span class="line">          <span class="type">ImageCache</span>.shared.image(forKey: <span class="string">"\(flickrPhoto.id)-filtered"</span>) &#123;</span><br><span class="line">          cell.imageView.image = cachedImage</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 2</span></span><br><span class="line">          <span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> filteredImage = image.applyTonalFilter() &#123;</span><br><span class="line">              <span class="type">ImageCache</span>.shared.<span class="keyword">set</span>(filteredImage, </span><br><span class="line">                                    forKey: <span class="string">"\(flickrPhoto.id)-filtered"</span>)</span><br><span class="line">            </span><br><span class="line">              <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">                cell.imageView.image = filteredImage</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Error: \(error)"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该代码的第一部分与之前相同，并从网上加载了Flickr照片的缩略图。如果照片是收藏夹，则单元格将显示缩略图而无需修改。但是，如果照片不是您的最爱，则会应用色调滤镜。</p><p>这是您更改内容的地方：</p><ol><li>检查图像缓存中是否存在针对该照片的过滤图像。如果是，那就太好了；显示该图像。</li><li>如果不是，请分派将色调过滤器应用到后台队列的调用。这允许UI在过滤器运行时保持响应。筛选器完成后，将图像保存在缓存中并更新主队列上的图像视图。</li></ol><p>那是经过过滤的图像，但是仍然有原始的 Flickr 缩略图需要解决。打开 <strong>Cache.swift</strong> 并查找<code>loadThumbnail(for:completion:)</code>。将其替换为以下内容：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadThumbnail</span><span class="params">(<span class="keyword">for</span> photo: FlickrPhoto,</span></span></span><br><span class="line"><span class="function"><span class="params">                   completion: @escaping FlickrAPI.FetchImageCompletion)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> image = <span class="type">ImageCache</span>.shared.image(forKey: photo.id) &#123;</span><br><span class="line">    completion(<span class="type">Result</span>.success(image))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">FlickrAPI</span>.loadImage(<span class="keyword">for</span>: photo, withSize: <span class="string">"m"</span>) &#123; result <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">case</span> .success(<span class="keyword">let</span> image) = result &#123;</span><br><span class="line">        <span class="type">ImageCache</span>.shared.<span class="keyword">set</span>(image, forKey: photo.id)</span><br><span class="line">      &#125;</span><br><span class="line">      completion(result)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这与您处理已过滤图像的方式非常相似。如果缓存中已存在图像，则可以立即与缓存的图像一起调用完 <code>completion closure</code>。否则，您将从 Flickr 加载图像并将其存储在缓存中。</p><p>按 <strong>Command-I</strong> 再次在 Instruments 中运行该应用程序。请注意，这次 Xcode 不会询问您要使用哪种 instrument。这是因为您仍然为应用程序打开了一个窗口，并且 Instruments 假设您想使用相同的选项再次运行。</p><p>再进行几次搜索。用户界面现在还不那么笨拙！该应用程序现在在后台应用图像过滤器并缓存结果，因此图像仅需过滤一次。您会在调用树中看到许多 <strong>dispatch_worker_threads</strong>。这些正在处理应用图像滤镜的繁重工作。</p><p>看起来很棒！现在该发货了吗？还没！</p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>那么，接下来您要查找什么错误？</p><p>项目中隐藏着一些您可能不知道的东西。您可能听说过内存泄漏。但是您可能不知道的是实际上存在两种泄漏：</p><ol><li><p>真正的内存泄漏：当对象不再被任何东西引用但仍被分配时发生。这意味着该内存将永远无法重复使用。</p><p> 即使借助 Swift 和 ARC 帮助管理内存，最常见的内存泄漏类型仍然是 <strong>retain cycle</strong> 或 <strong>strong reference cycle</strong>。当两个对象相互之间保持强引用时，就会发生这种情况，从而使每个对象都不会释放另一个对象。结果，他们的内存永远不会释放。</p></li><li><p>无限的内存增长：在连续分配内存且从未释放过内存的情况下发生。如果继续不检查，将耗尽内存。在iOS上，这意味着系统将终止您的应用。</p></li></ol><p>现在，您将探索 <strong>Allocations</strong> instrument。该工具为您提供有关应用程序创建的所有对象以及支持它们的内存的详细信息。它还显示您保留每个对象的计数。</p><h2 id="Allocations"><a href="#Allocations" class="headerlink" title="Allocations"></a>Allocations</h2><p>要从新的 instruments 重新开始，请退出 Instruments 应用。不必担心保存此特定运行。现在，在Xcode 中按 <strong>Command-I</strong>，从列表中选择 <strong>Allocations</strong>，然后单击 <strong>Choose</strong>。<br><img src="http://image.astudyer.com/16001702844905.jpg" alt="-w637"><br>片刻之后，您将看到 <strong>Allocations</strong> 工具。它对您应该很熟悉，因为它看起来很像 Time Profiler。<br><img src="http://image.astudyer.com/16001702844916.jpg" alt="-w1518"><br>单击左上角的 <strong>Record</strong> 按钮以运行该应用程序。这次您会注意到两条音轨。出于本教程的目的，您只需要关注 <strong>All Heap and Anonymous VM</strong>。<br><img src="http://image.astudyer.com/16001702844927.jpg" alt="-w1341"><br>在应用程序上运行 <strong>Allocations</strong> 工具后，可以在应用程序中进行五次不同的搜索，但仍不深入查询结果。确保搜索得到一些结果。现在，让应用程序等待几秒钟来解决问题。<br><img src="http://image.astudyer.com/16001702844937.jpg" alt="-w266"><br>您应该已经注意到 <strong>All Heap and Anonymous VM</strong> 轨道中的图形一直在上升。这告诉您您的应用正在分配内存。正是这一功能将指导您找到无限的内存增长。</p><h2 id="世代分析"><a href="#世代分析" class="headerlink" title="世代分析"></a>世代分析</h2><p>您将要执行的是<strong>世代分析</strong>。为此，请单击详细信息面板底部的 <strong>Mark Generation</strong> 按钮：<br><img src="http://image.astudyer.com/16001702844946.jpg" alt="-w476"><br>单击它，您将看到一条红旗出现在曲目中，如下所示：<br><img src="http://image.astudyer.com/16001702844955.jpg" alt="-w155"><br>生成分析的目的是多次执行一个动作，并查看内存是否以无限的方式增长。打开搜索结果，等待几秒钟以加载图像，然后返回主页。再次标记一代。重复执行此操作以进行不同的搜索。</p><p>检查了几次搜索后，Instruments 将如下所示：<br><img src="http://image.astudyer.com/16001702844967.jpg" alt="-w1341"><br>此时，您应该变得可疑了。请注意，您每次进行深入的搜索时，蓝色图形都会随着上升。好吧，那当然不是很好。但是等等，内存警告呢？你知道这些吧？</p><h2 id="模拟内存警告"><a href="#模拟内存警告" class="headerlink" title="模拟内存警告"></a>模拟内存警告</h2><p>内存警告是 iOS 告知应用程序内存部门越来越紧张并且需要清除一些内存的方式。</p><p>这种增长可能不仅取决于您的应用程序。这可能是 UIKit 深入存储的东西。让系统框架和您的应用有机会先清除它们的内存，然后再将它们指向任何一个。</p><p>通过在 Instruments 菜单栏中选择 <strong>Instrument ▸ Simulate Memory Warning</strong> 或从模拟器的菜单栏中选择 <strong>Hardware ▸ Simulate Memory Warning</strong> 来模拟内存警告。您会注意到内存使用量有所下降，或者根本没有下降。当然不会回到应该的位置。因此，某处仍存在无限的内存增长。</p><p>您在检查搜索的每个迭代之后都标记了一个世代，这样您就可以看到每个世代之间分配了什么内存。在详细信息面板中查看，您会看到很多代。</p><p>在每一代中，您将看到标记该代时已分配并仍驻留的所有对象。自从上一代被标记以来，后代将只包含对象。</p><p>查看 <strong>Growth</strong> 列，您会发现肯定有某处发生了增长。打开其中几代，您将看到以下内容：<br><img src="http://image.astudyer.com/16001702844977.jpg" alt="-w588"><br>哇，有很多东西！从哪里开始？</p><p>简单。单击 <strong>Growth</strong> 标题以按大小排序。确保最重的物体在顶部。在每一代的顶部附近，您会注意到一列标记为 <strong>VM：CoreImage</strong>，听起来确实很熟悉！单击 <strong>VM：CoreImage</strong> 左侧的箭头以显示与此项目关联的内存地址。选择第一个内存地址以在右侧面板上的扩展详细信息检查器中显示关联的堆栈跟踪：<br><img src="http://image.astudyer.com/16001702844989.jpg" alt="-w1343"><br>此堆栈跟踪显示了创建此特定对象的时间。灰色的堆栈跟踪部分位于系统库中。黑色部分在您应用的代码中。嗯，有些东西看起来很熟悉：有些黑字显示您的老朋友 <code>collectionView(_:cellForItemAt:)</code>。双击任何这些条目；Instruments 将在其上下文中显示代码。</p><p>看一下该方法。它 <code>set(_:forKey:)</code> 在第79行进行调用。请记住，此方法将缓存图像，以防再次在应用程序中使用它。听起来确实是个问题！</p><p>再次，单击 <strong>Open in Xcode</strong> 以跳回Xcode。打开 <strong>Cache.swift</strong> 并查看 <code>set(_:forKey:)</code> 方法实现：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(<span class="number">_</span> image: UIImage, forKey key: String)</span></span> &#123;</span><br><span class="line">  images[key] = image</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这会将图像添加到字典，并在 Flickr 照片的照片 ID 上键入。但是，您会注意到该图片从未从该词典中清除！</p><p>那就是您无限内存增长的来源。一切都按预期进行，但该应用程序永远不会从缓存中删除内容-它只会添加内容！</p><p>要解决此问题，您需要做的就是 <code>ImageCache</code> 监听内存警告通知 <code>UIApplication</code>。当 <code>ImageCache</code> 收到此消息时，它必须是好公民并清除其缓存。</p><p>要ImageCache监听通知，请打开 <strong>Cache.swift</strong> 并将以下初始化程序添加到该类：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span>() &#123;</span><br><span class="line">  <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(</span><br><span class="line">    forName: <span class="type">UIApplication</span>.didReceiveMemoryWarningNotification,</span><br><span class="line">    object: <span class="literal">nil</span>,</span><br><span class="line">    queue: .main) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] notification <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">self</span>?.images.removeAll(keepingCapacity: <span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这将注册一个观察者 <code>UIApplicationDidReceiveMemoryWarningNotification</code> 以执行闭包清理图片。</p><p>该代码所需要做的就是删除缓存中的所有对象。这样可以确保不再保留任何图像并将它们释放。</p><p>要测试此修复程序，请再次启动 Instruments，然后重复之前执行的步骤。不要忘了最后的模拟内存警告。</p><blockquote><p>注意：确保您从Xcode启动，触发构建，而不只是点击Instruments中的红色按钮，以确保您使用的是最新代码。您可能还需要先构建并运行，然后再进行性能分析。如果您只是进行Profile，有时Xcode似乎不会将模拟器中的应用程序版本更新为最新版本。</p></blockquote><p>这次，世代分析应如下所示：<br><img src="http://image.astudyer.com/16001702844999.jpg" alt="-w640"><br>您会注意到内存警告后内存使用率下降。总体而言，内存仍在增长，但远未达到以前。</p><p>仍然有一定增长的原因实际上是由于系统库，您对此无能为力。看来系统库并未释放它们的所有内存，这可能是设计使然，也可能是错误。您在应用中可以做的就是释放尽可能多的内存，而您已经做到了！</p><p>做得好！修补了另一个问题！现在一定是时候发货了！哦，等等-仍然存在您尚未解决的第一类泄漏问题。</p><h2 id="强引用循环"><a href="#强引用循环" class="headerlink" title="强引用循环"></a>强引用循环</h2><p>如前所述，当两个对象彼此保持强引用时，就会发生强引用循环，从而防止两个对象都被释放。您可以使用 Allocations 工具以其他方式检测这些周期。</p><p>关闭仪器并返回到Xcode。再次选择 <strong>Product ▸ Profile</strong>，然后选择 <strong>Allocations</strong>。<br><img src="http://image.astudyer.com/16001702845009.jpg" alt="-w637"><br>这次，您将不再使用世代分析。相反，您将查看在内存中徘徊的不同类型的对象的数量。单击 <strong>Record</strong> 按钮开始运行。您应该已经看到大量对象填充了详细信息面板-太多了！为了仅缩小目标对象的范围，请在左下角的字段中输入 <strong>“Instruments”</strong> 作为过滤器。<br><img src="http://image.astudyer.com/16001702845019.jpg" alt="-w641"><br>在 Instruments 中值得注意的两列是＃<strong>Persistent</strong>和＃<strong>Transient</strong>。＃Persistent 列保留内存中当前存在的每种类型的对象数。＃Transient 列显示了已存在但已释放的对象数。持久对象正在消耗内存；暂态对象不是。</p><h2 id="查找持久对象"><a href="#查找持久对象" class="headerlink" title="查找持久对象"></a>查找持久对象</h2><p>您应该看到存在的持久实例 <code>ViewController</code>。这很有意义，因为这就是您当前正在查看的屏幕。还有一个应用程序实例 <code>AppDelegate</code>。</p><p>回到应用程序！执行搜索并深入研究结果。请注意，Instruments 中现在显示了许多额外的对象：<code>SearchResultsViewController</code> 和 <code>ImageCache</code> 等。该 <code>ViewController</code> 实例仍然是持久性的，因为其导航控制器需要它。</p><p>现在点击应用程序中的后退按钮。这将弹出 <code>SearchResultsViewController</code> 导航堆栈，因此应将其释放。但是它在分配摘要中仍显示＃Persistent1 ！为什么还在那里？</p><p>尝试执行另外两个搜索，然后在每个搜索之后点击“后退”按钮。现在有三个<code>SearchResultsViewControllers</code>？！这些视图控制器在内存中徘徊的事实意味着某些东西一直在强烈地引用它们。看来您有很强的引用周期！<br><img src="http://image.astudyer.com/16001702845029.jpg" alt="-w637"><br>在这种情况下，您的主要线索不仅是 <code>SearchResultsViewController</code> 持久性，而且也包括所有 <code>SearchResultsCollectionViewCells</code>。引用周期很可能介于这两个类之间。</p><p>幸运的是，Xcode 8中引入的 <strong>Visual Memory Debugger</strong> 是一个简洁的工具，可以帮助您进一步诊断内存泄漏并保留周期。<strong>Visual Memory Debugger</strong> 不是 Xcode 的 Instrument 套件的一部分，但是它是一个非常有用的工具，值得在本教程中包括。来自分配工具和可视内存调试器的交叉引用见解是一项强大的技术，可以使您的调试工作流更加有效。</p><h2 id="Visual-Memory-Debugger"><a href="#Visual-Memory-Debugger" class="headerlink" title="Visual Memory Debugger"></a>Visual Memory Debugger</h2><p>退出 Instruments。</p><p>在启动 <strong>Visual Memory Debugger</strong> 之前，请像下面这样在 Xcode 方案编辑器中启用 <strong>Malloc</strong> 堆栈日志记录：Option-单击窗口顶部（“停止”按钮旁边）的 <strong>InstrumentsTutorial</strong> scheme。在出现的弹出窗口中，选择 <strong>Run</strong>，然后切换到 <strong>Diagnostics</strong> 选项卡。选中显示 <strong>Malloc Stack</strong> 的框，然后选择 <strong>Live Allocations Only</strong> 选项，然后单击 <strong>Close</strong>。<br><img src="http://image.astudyer.com/16001702845039.jpg" alt="-w626"><br>直接从 Xcode 启动应用程序。和以前一样，至少执行三个搜索以累积一些数据。</p><p>现在，像这样激活可视内存调试器：<br><img src="http://image.astudyer.com/16001702845051.jpg" alt="-w861"></p><ol><li>切换到 <strong>Debug</strong> 导航器。</li><li>单击此图标，然后从弹出窗口中选择 <strong>View Memory Graph Hierarchy</strong>。</li><li>单击的条目 <code>SearchResultsCollectionViewCell</code>。</li><li>您可以单击图形上的任何对象，以在检查器窗格中查看详细信息。</li><li>您可以在此区域中查看详细信息。在此处切换到内存检查器。</li></ol><p><strong>Visual Memory Debugger</strong> 会暂停您的应用程序，并以直观的方式显示内存中的对象及其之间的引用。</p><p>如上面的屏幕快照中突出显示的那样，Visual Memory Debugger显示以下信息：</p><ul><li><strong>堆内容</strong>（调试导航器窗格）：这将显示您暂停应用程序时在内存中分配的所有类型和实例的列表。单击一种类型将展开该行，以向您显示该类型在内存中的单独实例。</li><li><strong>内存图</strong>（主窗口）：主窗口以可视方式表示内存中的对象。对象之间的箭头表示它们之间的引用（强关系和弱关系）。</li><li><strong>内存检查器</strong>（实用程序窗格）：这包括详细信息，例如类名和层次结构，以及引用是强还是弱。</li></ul><p>请注意，调试导航器中的某些行旁边如果带有括号。括号中的数字表示内存中有多少个特定类型的实例。在上面的屏幕截图中，您可以看到经过几次搜索后，Visual Memory Debugger 会确认您在 <strong>Allocations</strong> 工具中看到的结果。换句话说，从20到（如果您滚动到搜索结果的末尾）的任何位置SearchResultsCollectionViewCell，每个 SearchResultsViewController 实例的60个实例都将保留在内存中。</p><p>使用该行左侧的箭头展开该类型并显示 SearchResultsViewController 内存中的每个实例。单击单个实例将在主窗口中显示该实例及其任何引用。<br><img src="http://image.astudyer.com/16002243673096.jpg" alt="-w924"><br>请注意指向 SearchResultsViewController 实例的箭头。似乎有一些 Swift 闭包上下文实例引用了相同的视图控制器实例。看起来有点怀疑，不是吗？细看。选择其中一个箭头，以在“实用程序”窗格中显示有关这些关闭实例之一与的引用的更多信息 SearchResultsViewController。<br><img src="http://image.astudyer.com/16002243673109.jpg" alt="-w859"><br>在内存检查，你可以看到 Swift 闭包上下文实例和 SearchResultsViewController 为强。如果在 SearchResultsCollectionViewCell 和闭包上下文之间选择引用，您也会看到它也标记为强。您还可以看到闭包的名称是 <strong>“heartToggleHandler”</strong>。哈！SearchResultsCollectionViewCell 表明这一点！</p><p>SearchResultsCollectionViewCell 在主窗口中选择的实例，以在检查器窗格上显示更多信息。<br><img src="http://image.astudyer.com/16002243673118.jpg" alt="-w887"><br>在回溯中，您可以看到在中初始化了单元实例 <code>collectionView(_:cellForItemAt:)</code>。当您将鼠标悬停在回溯中的这一行上时，将出现一个小箭头。单击箭头将带您进入Xcode的代码编辑器中的此方法。</p><p>在 <code>collectionView(_:cellForItemAt:)</code> 方法中，找到 <code>heartToggleHandler</code> 设置每个单元格属性的位置。您将看到以下代码行：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cell.heartToggleHandler = &#123; isStarred <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">self</span>.collectionView.reloadItems(at: [indexPath])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当用户在集合视图单元格中单击“心形”按钮时，将执行此关闭操作。这是强引用循环的所在，但是除非您之前遇到过，否则很难找到。但是由于有了Visual Memory Debugger，您才能够一直跟踪到这段代码！</p><p>SearchResultsViewController 的闭包中使用了 self，它创建了一个强引用。闭包捕获了 self。Swift 实际上会强迫您在闭包中显式使用 self，而在引用当前对象的方法和属性时，通常可以将其删除。这可以帮助您更多地了解正在捕获的实例。SearchResultsViewController 通过collection view 还对 cells 具有强应用。</p><h2 id="打破循环引用"><a href="#打破循环引用" class="headerlink" title="打破循环引用"></a>打破循环引用</h2><p>为了打破循环引用，您可以将捕获列表定义为闭包定义的一部分。捕获列表可用于将闭包捕获的实例声明为 <strong>weak</strong> 或 <strong>unowned</strong>：</p><ul><li><strong>Weak</strong>：捕获的变量将来可能为nil时使用。如果它所引用的对象被释放，则引用变为nil。因此，它们是可选类型。</li><li><strong>Unowned</strong>：当闭包及其引用的对象始终具有相同的生存期并在同一时间被释放时，使用此属性。Unowned 引用的对象永远不会成为nil。</li></ul><p>要打破循环引用，请向其中添加捕获列表，<code>heartToggleHandler</code> 如下所示：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cell.heartToggleHandler = &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] isStarred <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">self</span>?.collectionView.reloadItems(at: [indexPath])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>声明 self 为 weak 意味着即使 collection view cells 拥有对 SearchResultsViewController 的引用，也可以将其释放，因为它们现在只是弱引用。同时释放了 SearchResultsViewController 也将会释放 collection view，进而释放 cells。</p><p>在Xcode中，再次按 <strong>Command-I</strong> 在 Instruments 中构建并运行该应用程序。</p><p>像以前一样，使用 <strong>Allocations</strong> instrument 在 <strong>Instruments</strong> 中再次查看该应用。记住要过滤结果以仅显示示例项目中的类。执行搜索，导航到结果并再次返回。SearchResultsViewController 向后导航时，您应该看到和其单元格已解除分配。它们显示瞬时实例，但没有持久实例。</p><p>循环坏了！发货吧！</p><h2 id="接下来"><a href="#接下来" class="headerlink" title="接下来"></a>接下来</h2><p>您可以使用本教程顶部或底部的 <strong>“下载材料”</strong> 按钮下载示例项目。</p><p>现在，您已经掌握了此 Instruments 教程的知识，现在就去尝试自己的代码，看看会出现什么有趣的事情！另外，请尝试使 Instruments 成为常规开发工作流程的一部分。</p><p>您应该相对频繁地通过 Instruments 运行代码，并在发布前对应用程序进行全面扫描，以确保尽可能多地遇到内存管理和性能问题。</p><p>现在，去制作一些很棒的，高效的应用程序吧！</p><h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><p><a href="https://koenig-media.raywenderlich.com/uploads/2019/08/InstrumentsTutorial-3.zip" target="_blank" rel="noopener">下载材料</a><br><a href="https://www.raywenderlich.com/4784723-instruments-tutorial-getting-started" target="_blank" rel="noopener">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;了解如何使用 Instruments 来捕获和修复应用程序中的内存问题和性能错误，以使其更快，响应速度更快。&lt;/p&gt;
&lt;p&gt;Version：Swift 5, iOS 13, Xcode 11&lt;/p&gt;
&lt;p&gt;除了通过添加功能来改进其应用程序外，所有优秀的应用程序开发人员还应该
      
    
    </summary>
    
      <category term="工具" scheme="http://blog.astudyer.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Instruments" scheme="http://blog.astudyer.com/tags/Instruments/"/>
    
      <category term="Swift" scheme="http://blog.astudyer.com/tags/Swift/"/>
    
      <category term="性能优化" scheme="http://blog.astudyer.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="iOS" scheme="http://blog.astudyer.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>如何在IDEA中创建web项目并部署到Tomcat中</title>
    <link href="http://blog.astudyer.com/java/java/%E5%A6%82%E4%BD%95%E5%9C%A8IDEA%E4%B8%AD%E5%88%9B%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0Tomcat%E4%B8%AD.html"/>
    <id>http://blog.astudyer.com/java/java/如何在IDEA中创建web项目并部署到Tomcat中.html</id>
    <published>2018-07-22T08:11:25.000Z</published>
    <updated>2020-09-14T01:44:08.313Z</updated>
    
    <content type="html"><![CDATA[<h2 id="新建Web工程"><a href="#新建Web工程" class="headerlink" title="新建Web工程"></a>新建Web工程</h2><p><img src="http://images.astudyer.com/new_project.jpg" alt></p><h2 id="创建classes和lib文件"><a href="#创建classes和lib文件" class="headerlink" title="创建classes和lib文件"></a>创建classes和lib文件</h2><p>classes用来存放编译后输出的class文件，lib用于存放第三方jar包<br><img src="http://images.astudyer.com/classes_lib.jpg" alt></p><h2 id="配置文件夹路径"><a href="#配置文件夹路径" class="headerlink" title="配置文件夹路径"></a>配置文件夹路径</h2><ol><li>File -&gt; Project Structure<br><img src="http://images.astudyer.com/file_project_structure.jpg" alt></li><li>Modules -&gt; Paths -&gt; Use module compile output path<br>将Output path和Test output path都选择为刚刚创建的classes文件夹<br><img src="http://images.astudyer.com/java_jsp_output_path.jpg" alt></li><li>在当前界面选择Dependencies -&gt; 选择Module SDK -&gt; 点击下面的“+”号 -&gt; 选择1 “Jars or Directories” -&gt; 选择刚刚创建的lib文件夹 -&gt; 选择“Jar Directory” -&gt; OK -&gt; Apply -&gt; OK<br><img src="http://images.astudyer.com/java_jsp_dependencies.jpg" alt><br><img src="http://images.astudyer.com/java_jsp_jar_directory.jpg" alt></li></ol><h2 id="配置Tomcat容器"><a href="#配置Tomcat容器" class="headerlink" title="配置Tomcat容器"></a>配置Tomcat容器</h2><ol><li>打开菜单Run -&gt; 选择Edit Configuration</li><li>点击“+”号 -&gt; 选择“Tomcat Server” -&gt; 选择“Local”<br><img src="http://images.astudyer.com/java_jsp_run_configurations.jpg" alt></li><li>在”Name”处输入新的服务名，点击”Application server”后面的”Configure…”，弹出Tomcat Server窗口，选择本地安装的Tomcat目录 -&gt; OK </li><li>取消勾选”After launch”，设置”HTTP port”和”JMX port”（默认值即可），点击 Apply -&gt; OK， 至此Tomcat配置完成<br><img src="http://images.astudyer.com/java_jsp_tomcat_server.jpg" alt></li></ol><h2 id="在Tomcat中部署并运行项目"><a href="#在Tomcat中部署并运行项目" class="headerlink" title="在Tomcat中部署并运行项目"></a>在Tomcat中部署并运行项目</h2><p>Run -&gt; Edit Configurations，进入”Run/Debug Configurations”窗口 -&gt; 选择刚刚建立的Tomcat容器 -&gt; 选择Deployment -&gt; 点击右边的“+”号 -&gt; 选择Artifact -&gt; 选择web项目 -&gt; Application context可以填“/hello”(此处随意，可以填写项目名，也可以不填) -&gt; Apply -&gt; OK<br><img src="http://images.astudyer.com/java_jsp_tomcat_deployment.jpg" alt></p><h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><p>修改index.jsp页面，然后直接在tomcat上面运行这个项目就可以了，运行成功后在浏览器中输入<a href="http://localhost:8080/javaweb/" target="_blank" rel="noopener">http://localhost:8080/javaweb/</a>就可以查看运行效果了<br><img src="http://images.astudyer.com/java_jsp_run_result.jpg" alt></p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p><img src="http://images.astudyer.com/java_jsp_result_failure.jpg" alt><br>运行后如果出现以上错误，原因是在终端里面启动了Tomcat，在idea中又再次启动后冲突了。只需要把终端里面启动的Tomcat关闭后再次运行项目即可</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>[1].<a href="https://www.cnblogs.com/1314wamm/p/7471164.html" target="_blank" rel="noopener">如何在IDEA中创建web项目并且部署到Tomcat中</a><br>[2].<a href="https://www.cnblogs.com/tongfukezhan/p/7729043.html" target="_blank" rel="noopener">Mac OS中IDEA配置完Tomcat后启动显示404</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;新建Web工程&quot;&gt;&lt;a href=&quot;#新建Web工程&quot; class=&quot;headerlink&quot; title=&quot;新建Web工程&quot;&gt;&lt;/a&gt;新建Web工程&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://images.astudyer.com/new_project.j
      
    
    </summary>
    
      <category term="java" scheme="http://blog.astudyer.com/categories/java/"/>
    
    
      <category term="JSP基础" scheme="http://blog.astudyer.com/tags/JSP%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>多线程基础</title>
    <link href="http://blog.astudyer.com/iOS/OC%E8%BF%9B%E9%98%B6/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80.html"/>
    <id>http://blog.astudyer.com/iOS/OC进阶/多线程基础.html</id>
    <published>2018-01-27T13:35:52.000Z</published>
    <updated>2020-09-14T01:44:08.313Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多线程简介"><a href="#多线程简介" class="headerlink" title="多线程简介"></a>多线程简介</h2><h3 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h3><ol><li>进程是指在系统中<code>正在运行</code>的一个应用程序</li><li>每个进程之间是<code>独立</code>的，每个进程均运行在其专用且受保护的内存空间内</li><li>比如同时打开迅雷、Xcode，系统就会分别启动2个进程<br><img src="http://images.astudyer.com/iOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B.jpg" alt></li><li>通过”活动监视器”可以查看Mac系统中所开启的进程</li></ol><h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><ol><li>1个进程要想执行任务，必须得有线程（每1个进程至少要有1条线程）</li><li>一个进程（应用程序）的所有任务都在线程中执行</li><li>比如使用酷狗播放音乐、使用迅雷下载电影，都需要在线程中执行<br><img src="http://images.astudyer.com/iOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/%E7%BA%BF%E7%A8%8B.jpg" alt></li></ol><h3 id="线程的串行"><a href="#线程的串行" class="headerlink" title="线程的串行"></a>线程的串行</h3><ol><li>1个线程中任务的执行是<code>串行</code>的</li><li>如果要在1个线程中执行多个任务，那么只能一个一个地按顺序执行这些任务</li><li>也就是说，在同一时间内，1个线程只能执行1个任务</li><li>比如在1个线程中下载3个文件（分别是文件A、文件B、文件C），因此也可以认为<code>线程是进程中的1条执行路径</code><br><img src="http://images.astudyer.com/iOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/%E4%B8%B2%E8%A1%8C.png" alt></li></ol><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="什么是多线程"><a href="#什么是多线程" class="headerlink" title="什么是多线程"></a>什么是多线程</h3><ol><li>1个进程中可以开启多条线程，每条线程可以并行（同时）执行不同的任务</li><li>如果把进程比作一个车间，那么线程就好比车间里面的工人</li><li>多线程技术可以提高程序的执行效率</li><li>比如同时开启3条线程分别下载3个文件（分别是文件A、文件B、文件C）<br><img src="http://images.astudyer.com/iOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" alt></li></ol><h3 id="多线程的原理"><a href="#多线程的原理" class="headerlink" title="多线程的原理"></a>多线程的原理</h3><ol><li>同一时间，CPU只能处理1条线程，只有1条线程在工作（执行）</li><li>多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换） </li><li>如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象</li><li>如果线程数量过多，CPU在多个线程之间频繁切换，将会消耗大量的CPU资源，每条线程被调度执行的频次会降低</li></ol><h3 id="多线程的优点"><a href="#多线程的优点" class="headerlink" title="多线程的优点"></a>多线程的优点</h3><ol><li>能适当提高程序的执行效率</li><li>能适当提高资源利用率（CPU、内存利用率）</li></ol><h3 id="多线程的缺点"><a href="#多线程的缺点" class="headerlink" title="多线程的缺点"></a>多线程的缺点</h3><ol><li>创建线程是有开销的，iOS下主要成本包括：内核数据结构（大约1KB）、栈空间（子线程512KB、主线程1MB，也可以使用-setStackSize:设置，但必须是4K的倍数，而且最小是16K），创建线程大约需要90毫秒的创建时间</li><li>如果开启大量的线程，会降低程序的性能</li><li>线程越多，CPU在调度线程上的开销就越大</li><li>程序设计更加复杂：比如线程之间的通信、多线程的数据共享</li></ol><h2 id="多线程在iOS开发中的应用"><a href="#多线程在iOS开发中的应用" class="headerlink" title="多线程在iOS开发中的应用"></a>多线程在iOS开发中的应用</h2><h3 id="什么是主线程"><a href="#什么是主线程" class="headerlink" title="什么是主线程"></a>什么是主线程</h3><p>一个iOS程序运行后，默认会开启1条线程，称为“主线程”或“UI线程”</p><h3 id="主线程的主要作用"><a href="#主线程的主要作用" class="headerlink" title="主线程的主要作用"></a>主线程的主要作用</h3><ol><li>显示/刷新UI界面</li><li>处理UI时间（比如点击事件、滚动事件、拖拽事件等）</li></ol><h3 id="主线程的注意点"><a href="#主线程的注意点" class="headerlink" title="主线程的注意点"></a>主线程的注意点</h3><ol><li>不要将比较耗时的操作放到主线程中</li><li>耗时操作会卡住主线程，严重影响UI的流畅度，给用户一种“卡”的坏体验</li></ol><p>主线程耗时操作示例：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//会等上面for循环里面的大量打印操作全部执行完才会打印“点击了屏幕”</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"点击了屏幕"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="iOS中多线程实现方案"><a href="#iOS中多线程实现方案" class="headerlink" title="iOS中多线程实现方案"></a>iOS中多线程实现方案</h3><p><img src="http://images.astudyer.com/iOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.jpg" alt></p><h2 id="pthread"><a href="#pthread" class="headerlink" title="pthread"></a>pthread</h2><p>示例：利用pthread开辟新线程<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    [<span class="keyword">self</span> pthreadDemo];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)pthreadDemo&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     pthread 是属于 POSIX 多线程开发框架 跨平台</span></span><br><span class="line"><span class="comment">     参数:</span></span><br><span class="line"><span class="comment">     1. 指向线程代号的指针</span></span><br><span class="line"><span class="comment">     2. 线程的属性</span></span><br><span class="line"><span class="comment">     3. 指向函数的指针</span></span><br><span class="line"><span class="comment">     4. 传递给该函数的参数</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     返回值</span></span><br><span class="line"><span class="comment">     - 如果是0，表示正确</span></span><br><span class="line"><span class="comment">     - 如果非0，表示出现错误</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    pthread_t threadID;</span><br><span class="line">    <span class="built_in">NSString</span> *param = <span class="string">@"Hello, aStudyer!"</span>;</span><br><span class="line">    <span class="keyword">int</span> result = pthread_create(&amp;threadID, <span class="literal">NULL</span>, &amp;childThread, (__bridge <span class="keyword">void</span> *)(param));</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == result) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"OK"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"error = %d"</span>,result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* childThread(<span class="keyword">void</span> *param)&#123;</span><br><span class="line">    <span class="comment">// 打印结果为currentThread = &lt;NSThread: 0x1c046bfc0&gt;&#123;number = 3, name = (null)&#125; --- param = Hello, aStudyer!</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThread = %@ --- param = %@"</span>,[<span class="built_in">NSThread</span> currentThread], param);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><h2 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h2><p><img src="http://images.astudyer.com/iOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/nsthread.png" alt></p><h3 id="用NSThread开辟新线程的几种方式"><a href="#用NSThread开辟新线程的几种方式" class="headerlink" title="用NSThread开辟新线程的几种方式"></a>用NSThread开辟新线程的几种方式</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)threadDemo1&#123;</span><br><span class="line">    <span class="comment">// 创建一个新线程</span></span><br><span class="line">    <span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(childThread:) object:<span class="string">@"aStudyer"</span>];</span><br><span class="line">    <span class="comment">// 开启线程</span></span><br><span class="line">    [thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)threadDemo2&#123;</span><br><span class="line">    <span class="comment">// 创建一个新线程 同时开启线程</span></span><br><span class="line">    [<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(childThread:) toTarget:<span class="keyword">self</span> withObject:<span class="string">@"aStudyer"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)threadDemo3&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     创建一个新线程 同时开启线程</span></span><br><span class="line"><span class="comment">     InBackground 就是在后台（子线程）运行</span></span><br><span class="line"><span class="comment">     该方法是NSObject的一个分类方法 所有的NSObject对象都可以使用这个方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    [<span class="keyword">self</span> performSelectorInBackground:<span class="keyword">@selector</span>(childThread:) withObject:<span class="string">@"aStudyer"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)childThread:(<span class="keyword">id</span>)obj&#123;</span><br><span class="line">    <span class="comment">// 打印结果：currentThread = &lt;NSThread: 0x1c427be00&gt;&#123;number = 3, name = (null)&#125; --- obj = aStudyer</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThread = %@ --- obj = %@"</span>,[<span class="built_in">NSThread</span> currentThread],obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="exit方法"><a href="#exit方法" class="headerlink" title="exit方法"></a>exit方法</h3><p>exit方法可以杀掉当前线程，如果杀掉的是主线程，程序不会挂掉，但是会使所有的UI控件无法响应点击事件</p><h4 id="杀掉主线程"><a href="#杀掉主线程" class="headerlink" title="杀掉主线程"></a>杀掉主线程</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"来到了主线程"</span>);</span><br><span class="line">    [<span class="keyword">self</span> exitMainThread];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)exitMainThread&#123;</span><br><span class="line">    [<span class="keyword">self</span> performSelectorInBackground:<span class="keyword">@selector</span>(childThread) withObject:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">//这一句会杀掉主线程，但是程序不会崩溃</span></span><br><span class="line">    [<span class="built_in">NSThread</span> exit];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)childThread&#123;</span><br><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">NSThread</span> *mainThread = [<span class="built_in">NSThread</span> mainThread];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"mainThread = %@"</span>,mainThread);</span><br><span class="line">    <span class="comment">//[mainThread start];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，点击屏幕，打印结果如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">来到了主线程</span><br><span class="line">mainThread = &lt;NSThread: 0x1c4072480&gt;&#123;number = 4, name = (null)&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到此时通过<code>[NSThread mainThread]</code>获取的线程已经不是主线程</p><p>再次点击屏幕，并没有打印<code>来到了主线程</code>这句话，而是打印出了下面这样一句话<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[general] Attempting to wake up main runloop, but the main thread as exited. This message will only log once. Break on _CFRunLoopError_MainThreadHasExited to debug.</span><br></pre></td></tr></table></figure></p><p>如果在杀掉主线程之后，再次对主线程发送<code>start</code>消息会导致程序崩溃，打开第<code>16</code>行被注释掉的代码，再次运行项目，程序崩溃，错误信息如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*** Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;*** -[NSThread start]: attempt to start the thread again&apos;</span><br><span class="line">*** First throw call stack:</span><br><span class="line">(0x184801d04 0x183a50528 0x184801c4c 0x185124978 0x10051e754 0x1851f2860 0x18442c31c 0x18442c1e8 0x18442ac28)</span><br><span class="line">libc++abi.dylib: terminating with uncaught exception of type NSException</span><br></pre></td></tr></table></figure></p><h4 id="杀掉其它线程"><a href="#杀掉其它线程" class="headerlink" title="杀掉其它线程"></a>杀掉其它线程</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"来到了主线程"</span>);</span><br><span class="line">    [<span class="keyword">self</span> exitThread];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)exitThread&#123;</span><br><span class="line">    [<span class="keyword">self</span> performSelectorInBackground:<span class="keyword">@selector</span>(childThread) withObject:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)childThread&#123;</span><br><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"来了"</span>);</span><br><span class="line">    [<span class="built_in">NSThread</span> exit];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"到底能不能来？"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出信息如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">来到了主线程</span><br><span class="line">来了</span><br></pre></td></tr></table></figure></p><p>可以看到在<code>exit</code>后面的<code>到底能不能来？</code>没有被打印</p><h3 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h3><p>在利用多线程进行编程的时候，很容易不小心发生各种各样的错误。比如下面一段代码<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    [<span class="keyword">self</span> thread];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)thread&#123;</span><br><span class="line">    <span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(childThread) object:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">//thread.name = @"thread_aStudyer";</span></span><br><span class="line">    [thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)childThread&#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    [array addObject:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行项目，点击屏幕，程序发生崩溃。此时Xcode左侧的堆栈信息为<br><img src="http://images.astudyer.com/iOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/thread_no_name.jpg" alt><br>打开第<code>7</code>行被注释掉的代码，再次运行项目，崩溃堆栈信息为<br><img src="http://images.astudyer.com/iOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/thread_with_name.jpg" alt><br>通过上面的对比，可以明显的看到给一个NSThread对象设置name属性的好处，在程序崩溃的时候，可以很直观的在堆栈信息里面看到具体崩溃在了哪个线程里面。</p><h2 id="多线程的安全隐患"><a href="#多线程的安全隐患" class="headerlink" title="多线程的安全隐患"></a>多线程的安全隐患</h2><h3 id="安全隐患"><a href="#安全隐患" class="headerlink" title="安全隐患"></a>安全隐患</h3><p>假设内存中存有一个int类型的数据17，<code>线程A</code>和<code>线程B</code>同时去读取这块内存，读出的数据都为17，然后分别在两个线程中执行+1的操作，假设线程A先执行完，然后把计算出来的结果<code>18</code>写入这块内存，然后线程B执行完毕，也把计算出来的结果<code>18</code>写入这块内存，显然，结果是不正确的。如下图所示<br><img src="http://images.astudyer.com/iOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/thread_hidden_danger.jpg" alt></p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>作用：可以保证在锁内的代码，同一时间，只有一条线程执行！<br>用法：<code>@synchronized(aLock)</code></p><blockquote><p>注：此处的aLock是一个<code>NSObject</code>对象，好比是锁在门上的一把锁，在各个线程中这个对象要求是相同的（就好像一个门只能对应一把锁，而不是每个人都有一把自己的锁），一般用<code>self</code>。另外需要注意的是<code>@synchronized</code>这个关键字xcode是<code>没有提示</code>的（可以手动加到代码块里面），我们需要手动去敲出来，由此也可见或许苹果官方是不太推荐使用该关键字的。</p></blockquote><p>比如下面的例子<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="comment">/**票数*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> tickets;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    <span class="comment">// 一共有9张电影票</span></span><br><span class="line">    <span class="keyword">self</span>.tickets = <span class="number">9</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 售票员A</span></span><br><span class="line">    <span class="built_in">NSThread</span> *ticketSellerA = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(sellTickets) object:<span class="literal">nil</span>];</span><br><span class="line">    ticketSellerA.name = <span class="string">@"售票员A"</span>;</span><br><span class="line">    [ticketSellerA start];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 售票员B</span></span><br><span class="line">    <span class="built_in">NSThread</span> *ticketSellerB = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(sellTickets) object:<span class="literal">nil</span>];</span><br><span class="line">    ticketSellerB.name = <span class="string">@"售票员B"</span>;</span><br><span class="line">    [ticketSellerB start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sellTickets&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">YES</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 假设卖票时间为1秒</span></span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1.0</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">self</span>.tickets--;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"剩下%zd张票   %@"</span>,<span class="keyword">self</span>.tickets,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 票卖完了，就提示顾客</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"卖完了！%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>某次的运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">2018-01-29 07:23:42.887429+0800 lockDemo[15207:4371417] 剩下8张票   &lt;NSThread: 0x1c427a6c0&gt;&#123;number = 3, name = 售票员A&#125;</span><br><span class="line">2018-01-29 07:23:42.888246+0800 lockDemo[15207:4371418] 剩下7张票   &lt;NSThread: 0x1c4464880&gt;&#123;number = 4, name = 售票员B&#125;</span><br><span class="line">2018-01-29 07:23:43.892621+0800 lockDemo[15207:4371418] 剩下6张票   &lt;NSThread: 0x1c4464880&gt;&#123;number = 4, name = 售票员B&#125;</span><br><span class="line">2018-01-29 07:23:43.892626+0800 lockDemo[15207:4371417] 剩下6张票   &lt;NSThread: 0x1c427a6c0&gt;&#123;number = 3, name = 售票员A&#125;</span><br><span class="line">2018-01-29 07:23:44.897997+0800 lockDemo[15207:4371418] 剩下5张票   &lt;NSThread: 0x1c4464880&gt;&#123;number = 4, name = 售票员B&#125;</span><br><span class="line">2018-01-29 07:23:44.898170+0800 lockDemo[15207:4371417] 剩下4张票   &lt;NSThread: 0x1c427a6c0&gt;&#123;number = 3, name = 售票员A&#125;</span><br><span class="line">2018-01-29 07:23:45.903263+0800 lockDemo[15207:4371418] 剩下3张票   &lt;NSThread: 0x1c4464880&gt;&#123;number = 4, name = 售票员B&#125;</span><br><span class="line">2018-01-29 07:23:45.903504+0800 lockDemo[15207:4371417] 剩下2张票   &lt;NSThread: 0x1c427a6c0&gt;&#123;number = 3, name = 售票员A&#125;</span><br><span class="line">2018-01-29 07:23:46.908622+0800 lockDemo[15207:4371418] 剩下1张票   &lt;NSThread: 0x1c4464880&gt;&#123;number = 4, name = 售票员B&#125;</span><br><span class="line">2018-01-29 07:23:46.908863+0800 lockDemo[15207:4371417] 剩下0张票   &lt;NSThread: 0x1c427a6c0&gt;&#123;number = 3, name = 售票员A&#125;</span><br><span class="line">2018-01-29 07:23:46.908970+0800 lockDemo[15207:4371417] 卖完了！&lt;NSThread: 0x1c427a6c0&gt;&#123;number = 3, name = 售票员A&#125;</span><br><span class="line">2018-01-29 07:23:47.911235+0800 lockDemo[15207:4371418] 剩下-1张票   &lt;NSThread: 0x1c4464880&gt;&#123;number = 4, name = 售票员B&#125;</span><br><span class="line">2018-01-29 07:23:47.911435+0800 lockDemo[15207:4371418] 卖完了！&lt;NSThread: 0x1c4464880&gt;&#123;number = 4, name = 售票员B&#125;</span><br></pre></td></tr></table></figure></p><p>很明显结果有问题，第6张票在被售票员B卖过之后，售票员A并不知道，又卖了一次，最后当售票员A已经把所有票卖完的时候，售票员B以为还有1张票，又卖了一次，出现了-1张票这样的笑话。<br>解决方案是，我们应该给卖票过程加上一把锁，在售票员A卖票的过程（对总票数进行操作）售票员B要进行等待，我们把卖票部分的代码逻辑修改如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)sellTickets&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">YES</span>) &#123;</span><br><span class="line">        <span class="keyword">@synchronized</span>(<span class="keyword">self</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 假设卖票时间为1秒</span></span><br><span class="line">                [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1.0</span>];</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">self</span>.tickets--;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"剩下%zd张票   %@"</span>,<span class="keyword">self</span>.tickets,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 票卖完了，就提示顾客</span></span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"卖完了！%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再次运行项目，结果如下，可以看到此时卖票的结果就没有任何问题了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2018-01-29 07:47:43.046308+0800 lockDemo[15232:4379538] 剩下8张票   &lt;NSThread: 0x1c0269880&gt;&#123;number = 3, name = 售票员A&#125;</span><br><span class="line">2018-01-29 07:47:44.051738+0800 lockDemo[15232:4379539] 剩下7张票   &lt;NSThread: 0x1c026b640&gt;&#123;number = 4, name = 售票员B&#125;</span><br><span class="line">2018-01-29 07:47:45.056384+0800 lockDemo[15232:4379538] 剩下6张票   &lt;NSThread: 0x1c0269880&gt;&#123;number = 3, name = 售票员A&#125;</span><br><span class="line">2018-01-29 07:47:46.061467+0800 lockDemo[15232:4379539] 剩下5张票   &lt;NSThread: 0x1c026b640&gt;&#123;number = 4, name = 售票员B&#125;</span><br><span class="line">2018-01-29 07:47:47.066409+0800 lockDemo[15232:4379538] 剩下4张票   &lt;NSThread: 0x1c0269880&gt;&#123;number = 3, name = 售票员A&#125;</span><br><span class="line">2018-01-29 07:47:48.071435+0800 lockDemo[15232:4379539] 剩下3张票   &lt;NSThread: 0x1c026b640&gt;&#123;number = 4, name = 售票员B&#125;</span><br><span class="line">2018-01-29 07:47:49.080857+0800 lockDemo[15232:4379538] 剩下2张票   &lt;NSThread: 0x1c0269880&gt;&#123;number = 3, name = 售票员A&#125;</span><br><span class="line">2018-01-29 07:47:50.086129+0800 lockDemo[15232:4379539] 剩下1张票   &lt;NSThread: 0x1c026b640&gt;&#123;number = 4, name = 售票员B&#125;</span><br><span class="line">2018-01-29 07:47:51.096704+0800 lockDemo[15232:4379538] 剩下0张票   &lt;NSThread: 0x1c0269880&gt;&#123;number = 3, name = 售票员A&#125;</span><br><span class="line">2018-01-29 07:47:51.096967+0800 lockDemo[15232:4379539] 卖完了！&lt;NSThread: 0x1c026b640&gt;&#123;number = 4, name = 售票员B&#125;</span><br><span class="line">2018-01-29 07:47:51.097582+0800 lockDemo[15232:4379538] 卖完了！&lt;NSThread: 0x1c0269880&gt;&#123;number = 3, name = 售票员A&#125;</span><br></pre></td></tr></table></figure></p><h3 id="原子属性"><a href="#原子属性" class="headerlink" title="原子属性"></a>原子属性</h3><p>用<code>atomic</code>修饰的属性是原子属性，是线程安全的，在多个线程写入这个属性的时候，保证同一时间只有一个线程能够执行。原子属性内部有一个锁，称为<code>自旋锁</code>。<br><code>自旋锁和互斥锁的共同点与区别？</code><br>共同点：<br>都能够保证线程安全<br>不同点：<br>互斥锁：如果线程被锁在外面，就会进入休眠状态，等待锁打开，然后被唤醒！<br>自旋锁：如果线程被锁在外面，就会用死循环的方式，一直等待锁打开！</p><h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>GCD的全称是Grand Central Dispatch，可译为“牛逼的中枢调度器”。<br><strong>核心概念：</strong>将任务添加到队列，指定任务执行的方法<br><strong>任务：</strong>使用block封装<br><strong>队列（负责调度任务）</strong><br>串行队列：一个接一个的调度任务<br>并发队列：可以同时调度多个任务<br><strong>任务执行函数</strong>（任务都需要在线程中执行）<br>同步执行：当前指令不完成，不会执行下个指令，不会开辟新线程</p><h3 id="异步执行：当前指令不完成，不会等待，继续执行下一条指令，会开辟新线程"><a href="#异步执行：当前指令不完成，不会等待，继续执行下一条指令，会开辟新线程" class="headerlink" title="异步执行：当前指令不完成，不会等待，继续执行下一条指令，会开辟新线程"></a>异步执行：当前指令不完成，不会等待，继续执行下一条指令，会开辟新线程</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;多线程简介&quot;&gt;&lt;a href=&quot;#多线程简介&quot; class=&quot;headerlink&quot; title=&quot;多线程简介&quot;&gt;&lt;/a&gt;多线程简介&lt;/h2&gt;&lt;h3 id=&quot;什么是进程&quot;&gt;&lt;a href=&quot;#什么是进程&quot; class=&quot;headerlink&quot; title=&quot;什么是
      
    
    </summary>
    
      <category term="iOS" scheme="http://blog.astudyer.com/categories/iOS/"/>
    
    
      <category term="多线程" scheme="http://blog.astudyer.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>iOS中的消息转发机制</title>
    <link href="http://blog.astudyer.com/iOS/OC%E8%BF%9B%E9%98%B6/iOS%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6.html"/>
    <id>http://blog.astudyer.com/iOS/OC进阶/iOS中的消息转发机制.html</id>
    <published>2018-01-25T01:18:07.000Z</published>
    <updated>2020-09-14T01:44:08.312Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>假设我们有一个Person类和一个ViewController类，如下<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************* Person.h 文件 *******************************/</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)run;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="comment">/******************************* Person.m 文件 *******************************/</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    Person *p = [Person new];</span><br><span class="line">    [p run];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>编译代码，没有任何问题。运行项目，项目崩溃，报错信息为<code>-[Person run]: unrecognized selector sent to instance 0x1c0018a40</code>。作为一名iOS攻城狮，看到这样的错误信息，我们是不是感觉像见了老朋友一样亲切。但是你对这位老朋友真的了解吗？本文就将带你一起深入了解这位老朋友的身世之谜，为你揭露在iOS开发过程中，在程序运行期间，如果一个对象接收到一条无法解读的消息之后都会发生哪些情况？</p><blockquote><p>注意：本文的情况仅适用于在自己和自己的父类都找不到方法实现的情况，如果在自己或者自己的父类可以找到方法的实现，无论下面的消息转发流程有没有实现程序都仍然会按照通常的逻辑去执行。</p></blockquote><h2 id="消息转发流程"><a href="#消息转发流程" class="headerlink" title="消息转发流程"></a>消息转发流程</h2><p>iOS中一个对象接收到一条无法解读的消息的处理过程分为两大阶段。第一阶段先征询接收者，所属的类，看其是否能动态添加方法，以处理当前这个<code>unrecognized selector</code>，这叫做“动态方法解析”（dynamic method resolution）。第二阶段涉及“完整的消息转发机制”。如果运行期系统已经把第一阶段执行完了，那么接收者自己就无法再以动态新增方法的手段来响应包含该选择子的消息了。此时，运行期系统会请求消息接收者以其它手段来处理与消息相关的方法调用。这又细分为两小步。首先，请接收者看看有没有其他对象处理这条消息。若有，则运行期系统会把消息转给那个对象，于是消息转发过程结束，一起如常。若没有“备援接收者”，则启动完整的消息转发机制，系统会把与消息有关的全部细节都封装到NSInvocation对象中，再给接收者最后一次机会，令其设法解决当前还未处理的这条消息。如果仍然不能处理，就会给对象发送一个<code>unrecognized selector</code>消息，这就是iOS中消息转发机制的整个流程。</p><h2 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h2><p>由于iOS中Runtime机制，编译器在编译期间并不会对没有实现的方法进行报错，因为它不知道你会不会在程序运行期间动态的加上方法的实现。在程序运行期间，如果没有找到某个方法的实现，首先将调用其所属类的下列类方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel;</span><br></pre></td></tr></table></figure></p><p>此方法给这个对象一次动态添加方法的机会，如果想给对象在运行期间动态的添加一个方法，这里是一个很好的机会。如果尚未实现的方法是类方法，则会调用另一个方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)resolveClassMethod:(SEL)sel;</span><br></pre></td></tr></table></figure></p><p><strong>示例</strong>：修改上面的<code>Person.m</code>文件如下<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"><span class="comment">// 在这个方法中给对象动态添加方法的机会</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel&#123;</span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(run)) &#123;</span><br><span class="line">    <span class="comment">// 关于v@:的用法见下面的补充说明</span></span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, sel, (IMP)run, <span class="string">"v@:"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> run (<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ --- %s"</span>,<span class="keyword">self</span>, sel_getName(_cmd));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>再次运行项目，程序完美运行，控制台输出<code>&lt;Person: 0x1c4018fd0&gt; --- run</code></p><h2 id="备援接收者"><a href="#备援接收者" class="headerlink" title="备援接收者"></a>备援接收者</h2><p>如果Person类并没有实现上述方法，错过了动态添加方法的机会，系统还有第二次机会去处理未知消息，这一步，系统会询问Person类可不可以把该未知消息转发给其它对象去处理。方法如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector;</span><br></pre></td></tr></table></figure></p><p>其中的aSelector代表那条尚未被处理的未知消息，若当前接收者可以找到有能力处理该消息的对象，就把该对象在这个方法里面返回，否则就返回nil。<br><strong>示例</strong>：假如有另一个超人类<code>SuperMan</code>，如下<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************* SuperMan.h 文件 *******************************/</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SuperMan</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)run;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="comment">/******************************* SuperMan.m 文件 *******************************/</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"SuperMan.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SuperMan</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)run&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ --- 能力越大，责任越大！"</span>, <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>这个时候假设Person.m是下面这个样子<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"SuperMan.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这个方法中给对象动态添加方法的机会</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>,__func__);</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回备援的消息接收对象</span></span><br><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>,__func__);</span><br><span class="line">    <span class="keyword">return</span> [SuperMan new];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>运行项目，控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+[Person resolveInstanceMethod:]</span><br><span class="line">-[Person forwardingTargetForSelector:]</span><br><span class="line">&lt;SuperMan: 0x1c000e9f0&gt; --- 能力越大，责任越大！</span><br></pre></td></tr></table></figure></p><p>由此可见，系统在没有找到动态添加方法的时候，就会寻找备援接收者，找到之后，程序完美运行。那么如果找不到呢，接着往下看</p><h2 id="最后一次机会"><a href="#最后一次机会" class="headerlink" title="最后一次机会"></a>最后一次机会</h2><p>如果上面两次机会都错过了，那么系统将会启动完整的消息转发机制，给对象最后一次进行消息转发的机会。具体流程为</p><ol><li>执行<code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector;</code>对未知消息生成签名</li><li>执行<code>+ (BOOL)resolveInstanceMethod:(SEL)sel</code>动态添加签名成功的方法</li><li>执行<code>- (void)forwardInvocation:(NSInvocation *)anInvocation;</code>把所有消息相关的细节封装到一个<code>NSInvocation</code>对象中并唤醒方法</li><li>完成消息转发的整个流程。执行方法</li></ol><p><strong>示例</strong>：调整Person.m文件如下<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"SuperMan.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这个方法中给对象动态添加方法的机会</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>,__func__);</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回备援的消息接收对象</span></span><br><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>,__func__);</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成方法签名</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>,__func__);</span><br><span class="line">    <span class="built_in">NSString</span> *sel = <span class="built_in">NSStringFromSelector</span>(aSelector);</span><br><span class="line">    <span class="comment">// 判断需要转发的SEL</span></span><br><span class="line">    <span class="keyword">if</span> ([sel isEqualToString:<span class="string">@"run"</span>]) &#123;</span><br><span class="line">        <span class="comment">// 为转发方法生成签名</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="string">"v@:"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把所有消息相关的细节封装到anInvocation对象中并唤醒方法</span></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>,__func__);</span><br><span class="line">    SEL selector = [anInvocation selector];</span><br><span class="line">    <span class="comment">// 新建需要转发消息的对象</span></span><br><span class="line">    SuperMan *superMan = [SuperMan new];</span><br><span class="line">    <span class="keyword">if</span> ([superMan respondsToSelector:selector]) &#123;</span><br><span class="line">        <span class="comment">// 唤醒这个方法</span></span><br><span class="line">        [anInvocation invokeWithTarget:superMan];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>运行项目，控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+[Person resolveInstanceMethod:]</span><br><span class="line">-[Person forwardingTargetForSelector:]</span><br><span class="line">-[Person methodSignatureForSelector:]</span><br><span class="line">+[Person resolveInstanceMethod:]</span><br><span class="line">-[Person forwardInvocation:]</span><br><span class="line">&lt;SuperMan: 0x1c000e9f0&gt; --- 能力越大，责任越大！</span><br></pre></td></tr></table></figure></p><h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p>上面我们在用+ (BOOL)resolveInstanceMethod:(SEL)sel；动态添加方法的时候，可以看到有这样一句代码：<code>class_addMethod(self, sel, (IMP)run, &quot;v@:&quot;);</code>，对于其中的<code>v@:</code>字样，对此有些小伙伴可能不太理解是什么意思。这里简单说明一下。首先看一下苹果官方对<code>class_addMethod</code>方法的注释，可以看到对最后一个参数的解释是：<code>An array of characters that describe the types of the arguments to the method.</code>，意思就是该参数是由该方法的各个参数类型所组成的字符集。我们可以通过打印<code>@encode</code>的方式打印参数类型。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印结果为：void --- v</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"void --- %s"</span>, <span class="keyword">@encode</span>(<span class="keyword">void</span>));</span><br><span class="line"><span class="comment">// 打印结果为：self --- @</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"self --- %s"</span>, <span class="keyword">@encode</span>(<span class="keyword">id</span>));</span><br><span class="line"><span class="comment">// 打印结果为：SEL --- :</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"SEL --- %s"</span>, <span class="keyword">@encode</span>(SEL));</span><br></pre></td></tr></table></figure></p><p>所以上面的<code>v@:</code>的含义不言自明：分别代表了<code>run</code>这个方法的void和两个参数id和SEL的encode类型</p><blockquote><p>在iOS开发中，所有方法默认有两个参数，分别是方法调用者和方法编号，即上面动态方法解析那一步<code>run</code>方法里面的<code>id self</code>和<code>SEL _cmd</code>这两个参数，通常这两个参数我们可以不写。</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] <a href="http://www.cocoachina.com/ios/20160830/17424.html" target="_blank" rel="noopener">深入理解Objective-C消息转发机制</a><br>[2] <a href="http://www.cocoachina.com/ios/20150604/12013.html" target="_blank" rel="noopener">轻松学习之 Objective-C消息转发</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;假设我们有一个Person类和一个ViewController类，如下&lt;br&gt;&lt;figure class=&quot;highlight objc&quot;&gt;
      
    
    </summary>
    
      <category term="iOS" scheme="http://blog.astudyer.com/categories/iOS/"/>
    
    
      <category term="OC" scheme="http://blog.astudyer.com/tags/OC/"/>
    
  </entry>
  
  <entry>
    <title>深入理解iOS中的frame和bounds</title>
    <link href="http://blog.astudyer.com/iOS/OC%E8%BF%9B%E9%98%B6/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3iOS%E4%B8%AD%E7%9A%84frame%E5%92%8Cbounds.html"/>
    <id>http://blog.astudyer.com/iOS/OC进阶/深入理解iOS中的frame和bounds.html</id>
    <published>2018-01-24T09:49:11.000Z</published>
    <updated>2020-09-14T01:44:08.313Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在iOS开发界面的过程中，frame和bounds是两个非常常用的属性，这是两个非常容易混淆的概念，我们虽然经常用，但如果不清楚其原理，遇到了一些莫名其妙的问题可能会使我们不知所措，本来就将通过两个特殊场景来详细介绍一下二者的本质及区别。</p><h2 id="场景一（关于frame）"><a href="#场景一（关于frame）" class="headerlink" title="场景一（关于frame）"></a>场景一（关于frame）</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> screen_width = [<span class="built_in">UIScreen</span> mainScreen].bounds.size.width;</span><br><span class="line">    <span class="built_in">CGFloat</span> screen_height = [<span class="built_in">UIScreen</span> mainScreen].bounds.size.height;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIView</span> *bgView = [<span class="built_in">UIView</span> new];</span><br><span class="line">    bgView.frame = <span class="built_in">CGRectMake</span>((screen_width - <span class="number">200</span>) * <span class="number">0.5</span>, (screen_height - <span class="number">200</span>) * <span class="number">0.5</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">    bgView.backgroundColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:bgView];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIView</span> *subView = [<span class="built_in">UIView</span> new];</span><br><span class="line">    subView.backgroundColor = [<span class="built_in">UIColor</span> orangeColor];</span><br><span class="line">    subView.bounds = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    [bgView addSubview:subView];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>代码是不是很简单，仔细看一下，然后想象一下运行出来的效果，和下面的图形对照一下，看看和你想象的是不是一样。<br><img src="http://p2utrpfbk.bkt.clouddn.com/frame_bounds_cj1_result.jpeg" alt></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>那么为什么黄色视图不是从红色视图的左上角位置出现呢？</p><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>因为frame是<code>center</code>+<code>size</code>的组合模式，如果不设置center或者origin的话，那么默认center是CGPointZero，所以会出现上述状况。由此可知，改变origin的本质其实也是改变center。</p><h2 id="场景二（关于bounds）"><a href="#场景二（关于bounds）" class="headerlink" title="场景二（关于bounds）"></a>场景二（关于bounds）</h2><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> screen_width = [<span class="built_in">UIScreen</span> mainScreen].bounds.size.width;</span><br><span class="line">    <span class="built_in">CGFloat</span> screen_height = [<span class="built_in">UIScreen</span> mainScreen].bounds.size.height;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIView</span> *bgView = [<span class="built_in">UIView</span> new];</span><br><span class="line">    bgView.frame = <span class="built_in">CGRectMake</span>((screen_width - <span class="number">200</span>) * <span class="number">0.5</span>, (screen_height - <span class="number">200</span>) * <span class="number">0.5</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">    bgView.backgroundColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:bgView];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIView</span> *middleView = [<span class="built_in">UIView</span> new];</span><br><span class="line">    middleView.backgroundColor = [<span class="built_in">UIColor</span> orangeColor];</span><br><span class="line">    middleView.frame = <span class="built_in">CGRectMake</span>((bgView.frame.size.width - <span class="number">100</span>) * <span class="number">0.5</span>, (bgView.frame.size.height - <span class="number">100</span>) * <span class="number">0.5</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="comment">//注意这一行代码</span></span><br><span class="line">    middleView.bounds = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    [bgView addSubview:middleView];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIView</span> *smallView = [<span class="built_in">UIView</span> new];</span><br><span class="line">    smallView.backgroundColor = [<span class="built_in">UIColor</span> greenColor];</span><br><span class="line">    smallView.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">    [middleView addSubview:smallView];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，这个场景非常的简单，看完代码，你马上就可以在脑子里把UI效果构建出来。</p><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>问题是如果把其中的第<code>16</code>行代码修改为<code>middleView.bounds = CGRectMake(-50, -50, 100, 100);</code>会产生什么要的效果呢？</p><h3 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h3><p>实际效果如下图所示，看看和你想的是不是一样？然后想想一下为什么会出现这种现象？<br><img src="http://p2utrpfbk.bkt.clouddn.com/frame_bounds_cj2_result.jpeg" alt><br>可以发现，红色和黄色视图的位置不受影响，符合预期，绿色视图的frame的origin虽然设置为<code>{0,0}</code>，但是并没有出现在的黄色视图的左上角位置，而是向右大概偏移了50个像素，很显然，上面改动的第<code>16</code>行代码对绿色视图出现的位置造成了影响。</p><h3 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h3><p>事实上，bounds的<code>x</code>和<code>y</code>这两个参数描述的是自身左上角的那个点在本地坐标系中的坐标，默认情况下是<code>{0,0}</code>，如果设置为非零值，则会把该点的坐标强制转化为该非零值，上面16行中把该点坐标设置为<code>{-50,-50}</code>，所以该点坐标在本地坐标系中变为{-50,-50}，如果绿色视图想要在黄色视图的左上角位置出现，则需要把自身的origin设置为<code>{-50,-50}</code>，但是实际上我们给绿色视图的origin设置的是<code>{0,0}</code>，所以出现了上面向右偏移50个像素的现象。又因为改变的是黄色视图的本地坐标系，所以其父视图和自身不受影响。<br>综上，<code>bounds的x和y的值会影响其子视图出现的位置</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在iOS开发界面的过程中，frame和bounds是两个非常常用的属性，这是两个非常容易混淆的概念，我们虽然经常用，但如果不清楚其原理，遇到
      
    
    </summary>
    
      <category term="iOS" scheme="http://blog.astudyer.com/categories/iOS/"/>
    
    
      <category term="Objective-C" scheme="http://blog.astudyer.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>CocoaPods创建私有库</title>
    <link href="http://blog.astudyer.com/%E6%9E%B6%E6%9E%84/%E7%BB%84%E4%BB%B6%E5%8C%96/CocoaPods%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E5%BA%93.html"/>
    <id>http://blog.astudyer.com/架构/组件化/CocoaPods创建私有库.html</id>
    <published>2018-01-23T11:56:10.000Z</published>
    <updated>2020-09-14T01:44:08.314Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于CocoaPods"><a href="#关于CocoaPods" class="headerlink" title="关于CocoaPods"></a>关于CocoaPods</h2><p>做过iOS开发的小伙伴一定对CocoaPods不会陌生，其实CocoaPods不仅可以作为第三方库的管理工具，还可以很方便的创建和维护自己的私有仓库，实现复杂项目的插件化开发模式。不文不介绍CocoaPods的安装和基本用法，以及如何把代码提交到CocoaPods的公有仓库，想了解这些的小伙伴可以查看笔者<a href="http://localhost:4000/tags/CocoaPods/" target="_blank" rel="noopener"><code>CocoaPods标签</code></a>下的其它相关文章。</p><blockquote><p><strong>注意</strong>：本文的所有代码以创建在Github上面为例，其它的Git服务器原理一样。如果你不想让别人看到你的仓库代码，实现仓库的完全私有化，可以使用其它的可以创建私有项目的Git服务器，比如<a href="https://gitee.com/" target="_blank" rel="noopener">码云</a>、<a href="https://about.gitlab.com/" target="_blank" rel="noopener">GitLab</a>等。</p></blockquote><blockquote><p><strong>本文适用场景</strong>：假设你所在的团队项目中想要开发一个名为<code>CSTools</code>的插件，该插件可以使用CocoaPods进行管理，并且只有你自己的团队可以使用（别人用pod search命令搜索不到）。</p></blockquote><h2 id="创建私有仓库"><a href="#创建私有仓库" class="headerlink" title="创建私有仓库"></a>创建私有仓库</h2><p>1、在Github上创建一个新的Project，名字任意（比如名为private_pods_spec）作为私有仓库地址。<br>2、拷贝该项目的地址（http或者ssh的都可以）<br>3、在终端输入<code>pod repo add private_pods_spec 上一步的git地址</code>，其中<code>private_pods_spec</code>是仓库名字，可以随便起。<br>这几步完成之后，将会在你电脑上的<code>~/.cocoapods/repos</code>目录下生成一个名为private_pods_spec的文件夹，这个就是你创建出来的私有仓库，你随后开发的准备私有化的插件都可以放在这里面。</p><h2 id="在Github上创建插件工程"><a href="#在Github上创建插件工程" class="headerlink" title="在Github上创建插件工程"></a>在Github上创建插件工程</h2><p>在Github上创建一个新的Project，名为CSTools</p><h2 id="本地创建一个准备私有化的插件工程"><a href="#本地创建一个准备私有化的插件工程" class="headerlink" title="本地创建一个准备私有化的插件工程"></a>本地创建一个准备私有化的插件工程</h2><h3 id="利用模板自动创建"><a href="#利用模板自动创建" class="headerlink" title="利用模板自动创建"></a>利用模板自动创建</h3><p>在终端执行<code>pod lib create CSTools</code>，接下来的选项我们可以根据自己的情况酌情选择，无关紧要，这里笔者的选择示例如下。<br><img src="http://p2utrpfbk.bkt.clouddn.com/cocoapods_private_pod.png" alt><br>执行完以上操作，将会自动生成一个名为CSTools的示例Xcode工程，并已经以开发形式（以<code>pod &#39;CSTools&#39;, :path =&gt; &#39;../&#39;</code>的方式进行引用）引用了你想要开发的CSTools库。<br>删除掉<code>Pods/Development Pods/CSTools/CSTools/Classes</code>里面的ReplaceMe.m文件，并在这里创建一个Person类<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)sayHelloTo:(<span class="built_in">NSString</span> *)to;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)sayHelloTo:(<span class="built_in">NSString</span> *)to&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Hello, %@！"</span>,to);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：这个时候，在示例项目里面是找不到Person类和类里面写的方法的，需要在示例项目的Podfile路径下，执行<code>pod install</code>命令</p></blockquote><p>执行完<code>pod install</code>命令之后，在示例项目的<code>CSViewController.m</code>里面引用CSTools插件库测试所写插件的功能<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"CSViewController.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;CSTools/Person.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CSViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CSViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">//运行项目，正确的打印出：Hello,Lucy！</span></span><br><span class="line">    [Person sayHelloTo:<span class="string">@"Lucy"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><h3 id="手动创建"><a href="#手动创建" class="headerlink" title="手动创建"></a>手动创建</h3><p>手动创建的时候可以利用<code>pod spec create [NAME].spec</code>的方式创建插件的描述文件</p><h2 id="把插件推送到私有仓库"><a href="#把插件推送到私有仓库" class="headerlink" title="把插件推送到私有仓库"></a>把插件推送到私有仓库</h2><h3 id="修改-podspec文件"><a href="#修改-podspec文件" class="headerlink" title="修改.podspec文件"></a>修改.podspec文件</h3><p>打开.podspec文件，可以发现里面已经写了好多信息，我们只需要进行简单修改即可使用。<br><code>s.version</code>：插件版本，和Git服务器上最新的tag对应。<br><code>s.summary</code>：插件简介<br><code>s.description</code>：插件详细描述（字数要比s.summary写的长一点）<br><code>s.license</code>：遵循的开源协议，可以写为（s.license = ‘MIT’）<br><code>s.author</code>：开发者信息，你的用户名和邮箱<br><code>s.source</code>：插件地址，即上面第3步在Github上的插件地址<br>其它的参数这里不需要修改，不再逐一进行介绍，想要详细了解的可以自己百度</p><h3 id="验证-podspec文件的正确性"><a href="#验证-podspec文件的正确性" class="headerlink" title="验证.podspec文件的正确性"></a>验证.podspec文件的正确性</h3><p>在<code>CSTools.podspec</code>所在路径下，在终端执行命令：<code>pod lib lint CSTools.podspec</code><br>如果出现以下结果证明通过验证<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bogon:CSTools shc$ pod lib lint CSTools.podspec </span><br><span class="line"></span><br><span class="line"><span class="meta"> -&gt;</span><span class="bash"> CSTools (0.1.0)</span></span><br><span class="line"></span><br><span class="line">CSTools passed validation.</span><br></pre></td></tr></table></figure></p><h3 id="把示例项目打一个tag推送到Github上"><a href="#把示例项目打一个tag推送到Github上" class="headerlink" title="把示例项目打一个tag推送到Github上"></a>把示例项目打一个tag推送到Github上</h3><p>在示例项目根目录下，依次执行如下命令</p><ol><li><code>git add .</code></li><li><code>git commit -m &quot;init&quot;</code></li><li><code>git remote add origin 插件在Github上面的地址（第3步生成）</code></li><li><code>git push origin master</code></li><li><code>git tag -m &quot;the first release&quot; &quot;0.1.0&quot;</code></li><li><code>git push --tags</code></li></ol><blockquote><p>这些命令属于git基本语法，此处不做过多解释</p></blockquote><h3 id="把插件推送到私有仓库-1"><a href="#把插件推送到私有仓库-1" class="headerlink" title="把插件推送到私有仓库"></a>把插件推送到私有仓库</h3><p>在终端执行命令：<code>pod repo push REPO [NAME.podspec]</code><br>此命令将会首先检验NAME.podspec文件的合法性，然后会把NAME.podspec及对应的版本信息推送到私有仓库<br><code>REPO</code>：<code>~/.cocoapods/repos/</code>目录下私有私有仓库名字，本文示例工程为<code>private_pods_spec</code><br><code>NAME.podspec</code>：需要推送到私有插件库的插件描述信息文件，即本例工程里面的<code>CSTools.podspec</code>文件</p><blockquote><p>执行完命令将会在你电脑上的<code>~/.cocoapods/repos/private_pods_spec/</code>目录下新增加一个CSTools文件夹，里面有其对应的版本和描述文件。此时在命令行输入<code>pod search</code>命令发现已经可以找到刚刚生成的插件了。</p></blockquote><h2 id="使用私有插件库里面的插件"><a href="#使用私有插件库里面的插件" class="headerlink" title="使用私有插件库里面的插件"></a>使用私有插件库里面的插件</h2><p>新建一个iOS项目，在项目根目录下执行命令 <code>pod init</code>，打开生成的Podfile文件，在<code>platform</code>和<code>target</code>之间添加<code>source &#39;私有库git地址&#39;</code>，然后添加<code>pod &#39;CSTools&#39;</code>，最后执行<code>pod install</code>命令即可把之前写好的CSTool这个插件添加到工程中，具体配置如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Uncomment the next line to define a global platform for your project</span><br><span class="line">platform :ios, &apos;9.0&apos;</span><br><span class="line"></span><br><span class="line">#优先使用私有库，避免从github下载三方库</span><br><span class="line">source &apos;git@github.com:aStudyer/private_pods_spec.git&apos;</span><br><span class="line">#如果私有库找不到，再去Github下载开源库</span><br><span class="line">source &apos;https://github.com/CocoaPods/Specs.git&apos;</span><br><span class="line"></span><br><span class="line">target &apos;private_pods_test&apos; do</span><br><span class="line">  </span><br><span class="line">pod &apos;CSTools&apos;</span><br><span class="line">pod &apos;SDWebImage&apos;</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于CocoaPods&quot;&gt;&lt;a href=&quot;#关于CocoaPods&quot; class=&quot;headerlink&quot; title=&quot;关于CocoaPods&quot;&gt;&lt;/a&gt;关于CocoaPods&lt;/h2&gt;&lt;p&gt;做过iOS开发的小伙伴一定对CocoaPods不会陌生，其实Coco
      
    
    </summary>
    
      <category term="架构" scheme="http://blog.astudyer.com/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="组件化" scheme="http://blog.astudyer.com/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
      <category term="CocoaPods" scheme="http://blog.astudyer.com/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>OC语言系列——关于变量</title>
    <link href="http://blog.astudyer.com/iOS/OC%E5%9F%BA%E7%A1%80/OC%E8%AF%AD%E8%A8%80%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8E%E5%8F%98%E9%87%8F.html"/>
    <id>http://blog.astudyer.com/iOS/OC基础/OC语言系列——关于变量.html</id>
    <published>2018-01-18T14:23:22.000Z</published>
    <updated>2020-09-14T01:44:08.312Z</updated>
    
    <content type="html"><![CDATA[<p>变量可以分为全局变量、静态全局变量、静态局部变量和局部变量</p><p>按存储区域分：全局变量、静态全局变量和静态局部变量都存放在内存的全局数据区，局部变量存放在内存的栈区<br>按作用域分：全局变量在整个工程文件内都有效；静态全局变量只在定义它的文件内有效；静态局部变量只在定义它的函数内有效，只是程序仅分配一次内存，函数返回后，该变量不会消失；局部变量在定义它的函数内有效，但是函数返回后失效。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;变量可以分为全局变量、静态全局变量、静态局部变量和局部变量&lt;/p&gt;
&lt;p&gt;按存储区域分：全局变量、静态全局变量和静态局部变量都存放在内存的全局数据区，局部变量存放在内存的栈区&lt;br&gt;按作用域分：全局变量在整个工程文件内都有效；静态全局变量只在定义它的文件内有效；静态局部变量
      
    
    </summary>
    
      <category term="iOS" scheme="http://blog.astudyer.com/categories/iOS/"/>
    
    
      <category term="Objective-C" scheme="http://blog.astudyer.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>OC语言系列——Category</title>
    <link href="http://blog.astudyer.com/iOS/OC%E5%9F%BA%E7%A1%80/OC%E8%AF%AD%E8%A8%80%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94Category.html"/>
    <id>http://blog.astudyer.com/iOS/OC基础/OC语言系列——Category.html</id>
    <published>2018-01-14T07:57:31.000Z</published>
    <updated>2020-09-14T01:44:08.311Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/2018/OC/logo.jpg" alt></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>OC提供了一种与众不同的方式–Category，可以动态的为已经存在的类添加新的行为（方法）</li><li>这样可以保证类的原始设计规模大小，功能增加时再逐步扩展</li><li>使用Category对类进行扩展时，不需要创建子类</li><li>Category使用简单的方式，实现了类的相关方法的模块化，把不同的类方法分配到不同的分类文件中</li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>在定义类时的某些情况下（例如需求变更），你可能想要为其中的某个或几个类中添加新的方法</li><li>一个类中包含了许多不同种类的方法需要实现，而这些方法需要不同团队的成员实现</li><li>在使用基础类库中的类时，有可能希望这些类实现一些自己需要的方法，比如写个NSString+JSON.h为NSString这个类拓展一些解析JSON的方法</li></ul><h2 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h2><ul><li>Category可以访问原始类的实例变量，但不能添加变量，如果想添加变量，可以考虑通过继承创建子类</li><li>Category可以重载原始类的方法，但不推荐这么做，因为它是直接替换掉原来的方法，这么做的后果是再也不能访问原来的方法。如果确实需要重载，正确的选择是创建子类</li></ul><h2 id="类的私有方法"><a href="#类的私有方法" class="headerlink" title="类的私有方法"></a>类的私有方法</h2><ul><li>第一种方式：直接在.m文件中写方法实现，不要在.h文件中进行方法声明</li><li>第二种方式：在.m文件中定义一个Category，在Category中声明一些方法，然后在@implementation跟@end之间作方法实现</li></ul><h2 id="与类扩展-extension-的区别"><a href="#与类扩展-extension-的区别" class="headerlink" title="与类扩展(extension)的区别"></a>与类扩展(extension)的区别</h2><p>类扩展(extension）是category的一个特例，有时候也被称为<code>匿名分类</code>。它的作用是为一个类添加一些私有的成员变量和方法。</p><ul><li>和分类不同，类扩展即可以声明成员变量又可以声明方法。</li><li>类扩展可以定义在.m文件中，这种扩展方式中定义的变量都是私有的，也可以定义在.h文件中，这样定义的代码就是共有的，类扩展在.m文件中声明私有方法是非常好的方式。</li><li>类扩展中添加的新方法，一定要实现。Category中没有这种限制。</li></ul><h2 id="Category中为什么不能添加属性？"><a href="#Category中为什么不能添加属性？" class="headerlink" title="Category中为什么不能添加属性？"></a>Category中为什么不能添加属性？</h2><p>在分类里使用@property声明属性，只是将该属性添加到该类的属性列表，并声明了setter和getter方法，但是没有生成相应的成员变量，也没有实现setter和getter方法（可以用runtime机制在程序运行时打印该类的所有属性和方法，可以发现并没有为分类中的属性生成带下划线的同名成员变量）。所以说分类不能添加属性。<code>Category中不能添加属性的本质是Category中不允许添加成员变量</code>。</p><h2 id="Category如何添加成员变量"><a href="#Category如何添加成员变量" class="headerlink" title="Category如何添加成员变量"></a>Category如何添加成员变量</h2><p>虽然上面说Category不能添加属性，但是我们可以在分类的.h文件中使用@property声明属性后，在.m中手动的实现setter和getter方法，并且用runtime机制在程序运行时动态的为该属性关联对象，可以认为给这个类添加上了属性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/img/2018/OC/logo.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;OC提供了一种与众不同的方式–Cate
      
    
    </summary>
    
      <category term="iOS" scheme="http://blog.astudyer.com/categories/iOS/"/>
    
    
      <category term="Objective-C" scheme="http://blog.astudyer.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>OC语言系列——Block</title>
    <link href="http://blog.astudyer.com/iOS/OC%E5%9F%BA%E7%A1%80/OC%E8%AF%AD%E8%A8%80%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94Block.html"/>
    <id>http://blog.astudyer.com/iOS/OC基础/OC语言系列——Block.html</id>
    <published>2018-01-14T07:57:31.000Z</published>
    <updated>2020-09-14T01:44:08.311Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/2018/OC/block.jpg" alt></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>闭包是一个函数（或指向函数的指针），再加上该函数执行的外部的上下文变量（有时候也称作自由变量）。</li><li>Block实际上就是 Objective-C 语言对于闭包的实现。</li><li>Block封装了一段代码，可以在任何需要的时候执行</li><li>Block可以作为函数参数或者函数的返回值，而其本身又可以带输入参数或者函数的返回值。它和传统的函数指针很类似，但是有区别：block是inline（内联函数）的，并且默认情况下它对局部变量是只读的</li><li>苹果官方建议尽量多用block。在多线程、集合遍历、集合排序、动画转场用的较多</li></ul><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><img src="/img/2018/OC/block-struct.jpg" alt><br>对应的结构体定义如下：</p><pre><code>struct Block_descriptor {    unsigned long int reserved;    unsigned long int size;    void (*copy)(void *dst, void *src);    void (*dispose)(void *);};struct Block_layout {    void *isa;    int flags;    int reserved;    void (*invoke)(void *, ...);    struct Block_descriptor *descriptor;    /* Imported variables. */};</code></pre><p>通过该图，我们可以知道，一个 block 实例实际上由 6 部分构成：</p><ol><li><code>isa</code>：所有对象都有该指针，指向对象所在的类（由此说明block也是一个对象）。</li><li><code>flags</code>：用于按 bit 位表示一些 block 的附加信息，本文后面介绍 block copy 的实现代码可以看到对该变量的使用。</li><li><code>reserved</code>：保留变量。</li><li><code>invoke</code>：函数指针，指向具体的 block 实现的函数调用地址。</li><li><code>descriptor</code>：表示该 block 的附加描述信息，主要是 size 大小，以及 copy 和 dispose 函数的指针。</li><li><code>variables</code>：capture 过来的变量，block 能够访问它外部的局部变量，就是因为将这些变量（或变量的地址）复制到了结构体中。</li></ol><h3 id="Block的类型"><a href="#Block的类型" class="headerlink" title="Block的类型"></a>Block的类型</h3><p>在 Objective-C 语言中，一共有 3 种类型的 block：</p><ol><li><code>_NSConcreteGlobalBlock</code>：全局的静态 block，不会访问任何外部变量。</li><li><code>_NSConcreteStackBlock</code>：保存在栈中的 block，当函数返回时会被销毁。</li><li><code>_NSConcreteMallocBlock</code>：保存在堆中的 block，当引用计数为 0 时会被销毁。</li></ol><blockquote><p>对于_NSConcreteGlobalBlock变量执行copy，什么也不做<br>对于_NSConcreteStackBlock变量执行copy，会从栈复制到堆<br>对于_NSConcreteMallocBlock变量执行copy，引用计数增加</p></blockquote><h3 id="clang"><a href="#clang" class="headerlink" title="clang"></a>clang</h3><p>为了研究编译器是如何实现 block 的，我们需要使用 <code>clang</code>。clang 提供一个命令，可以将 Objetive-C 的源码改写成 c++ 语言的，借此可以研究 block 具体的源码实现方式。该命令是</p><pre><code>clang -rewrite-objc block.c</code></pre><h2 id="Block的存储区域"><a href="#Block的存储区域" class="headerlink" title="Block的存储区域"></a>Block的存储区域</h2><p><img src="/img/2018/OC/block_area.jpg" alt></p><h3 id="MRC环境下"><a href="#MRC环境下" class="headerlink" title="MRC环境下"></a>MRC环境下</h3><ol><li>不俘获任何变量<br><img src="/img/2018/OC/block_mrc_1.png" alt></li><li>只俘获全局变量<br><img src="/img/2018/OC/block_mrc_2.png" alt></li><li>俘获非全局变量的外部变量<br><img src="/img/2018/OC/block_mrc_3.png" alt></li><li>俘获用__block修饰的变量<br><img src="/img/2018/OC/block_mrc_4.png" alt></li><li>总结<br>I.在MRC中，如果一个Block不俘获任何变量，或者仅仅俘获全局变量，那么此Block属于全局的静态 Block（<code>_NSConcreteGlobalBlock</code>），存储在<code>.data区</code>，在全局的内存地址只有一个，执行copy操作，什么也不做。<br>II.在MRC中，如果一个Block俘获了非全局变量的外部变量，或者俘获了用__block修饰的变量，那么该Block不管是直接访问还是用变量进行访问，都存储在栈上。如果对该block执行了copy操作，则被拷贝到堆上。</li></ol><h3 id="ARC环境下"><a href="#ARC环境下" class="headerlink" title="ARC环境下"></a>ARC环境下</h3><ol><li>不俘获任何变量<br><img src="/img/2018/OC/block_arc_1.png" alt></li><li>只俘获全局变量<br><img src="/img/2018/OC/block_arc_2.png" alt></li><li>俘获非全局变量的外部变量<br><img src="/img/2018/OC/block_arc_3.png" alt></li><li>俘获用__block修饰的变量<br><img src="/img/2018/OC/block_arc_4.png" alt></li><li>总结<br>I.在ARC中，如果一个Block不俘获任何变量，或者仅仅俘获全局变量，那么此Block属于全局的静态 Block（<code>_NSConcreteGlobalBlock</code>），存储在<code>.data区</code>，在全局的内存地址只有一个，执行copy操作，什么也不做。<br>II.在ARC中，如果一个Block俘获了非全局变量的外部变量，或者俘获了用__block修饰的变量，那么该Block本身存储在栈上，使用变量访问这种Block时，访问到的是被复制到堆上的对象（所以才会有ARC模式下没有_NSConcreteStackBlock这种说法）。</li></ol><h2 id="Block的声明、赋值与调用"><a href="#Block的声明、赋值与调用" class="headerlink" title="Block的声明、赋值与调用"></a>Block的声明、赋值与调用</h2><h3 id="Block的声明"><a href="#Block的声明" class="headerlink" title="Block的声明"></a>Block的声明</h3><pre><code>Block变量的声明格式为: 返回值类型(^Block名字)(参数列表);// 声明一个无返回值,参数为两个字符串对象,名字为aBlock的Blockvoid(^aBlock)(NSString *x, NSString *y);// 形参变量名称可以省略,只留有变量类型即可void(^aBlock)(NSString *, NSString *);</code></pre><blockquote><p>注: ^被称作”脱字符”</p></blockquote><h3 id="Block的赋值"><a href="#Block的赋值" class="headerlink" title="Block的赋值"></a>Block的赋值</h3><pre><code>Block变量的赋值格式为: Block变量 = ^(参数列表){函数体};aBlock = ^(NSString *x, NSString *y){    NSLog(@&quot;%@ love %@&quot;, x, y);};</code></pre><blockquote><p>注: Block变量的赋值格式可以是: Block变量 = ^返回值类型(参数列表){函数体};不过通常情况下都将返回值类型省略，因为编译器可以从存储代码块的变量中确定返回值的类型</p></blockquote><h3 id="声明Block的同时进行赋值"><a href="#声明Block的同时进行赋值" class="headerlink" title="声明Block的同时进行赋值"></a>声明Block的同时进行赋值</h3><pre><code>int(^myBlock)(int) = ^(int num){    return num * 3;};// 如果没有参数列表,在赋值时参数列表可以省略void(^aVoidBlock)() = ^{    NSLog(@&quot;I am a aVoidBlock&quot;);};</code></pre><h3 id="使用typedef定义Block类型"><a href="#使用typedef定义Block类型" class="headerlink" title="使用typedef定义Block类型"></a>使用typedef定义Block类型</h3><p>在实际使用Block的过程中,我们可能需要重复的声明多个相同返回值相同参数列表的Block变量,如果总是重复地编写一长串代码来声明变量会非常繁琐,所以我们可以使用typedef来定义Block类型</p><pre><code>// 定义一种无返回值无参数列表的Block类型typedef void(^SayHello)();// 我们可以像OC中声明变量一样使用Block类型SayHello来声明变量SayHello hello = ^(){    NSLog(@&quot;hello&quot;);};// 调用后控制台输出&quot;hello&quot;hello();</code></pre><h3 id="Block的调用"><a href="#Block的调用" class="headerlink" title="Block的调用"></a>Block的调用</h3><pre><code>// 调用后控制台输出&quot;Li Lei love Han Meimei&quot;aBlock(@&quot;Li Lei&quot;,@&quot;Han Meimei&quot;);// 调用后控制台输出&quot;result = 9&quot;NSLog(@&quot;result = %d&quot;, myBlock(3));// 调用后控制台输出&quot;I am a aVoidBlock&quot;aVoidBlock();</code></pre><h2 id="Block俘获变量原理"><a href="#Block俘获变量原理" class="headerlink" title="Block俘获变量原理"></a>Block俘获变量原理</h2><ul><li><strong>对于 block 外的变量引用，block 默认是将其复制到其数据结构中来实现访问的</strong><br><img src="/img/2018/OC/block-capture-1.jpg" alt></li></ul><ol><li>在Block内部可以访问外部变量<br><img src="/img/2018/OC/block1.png" alt></li><li>在Block内部不可以修改外部变量（全局变量和静态变量除外）<br><img src="/img/2018/OC/block2.png" alt></li><li>在Block被赋值之后，调用之前修改外部变量，在调用Block时变量的值是修改之前的旧值<br><img src="/img/2018/OC/block3.png" alt></li></ol><ul><li><strong>对于用 __block 修饰的外部变量引用，block 是复制其引用地址来实现访问的</strong><br><img src="/img/2018/OC/block-capture-2.jpg" alt></li></ul><ol><li>用__block修饰的变量可以在Block内部被修改<br><img src="/img/2018/OC/block4.png" alt></li><li>用__block修饰的变量在Block被赋值之后，调用之前进行修改，在调用Block时变量的值是修改之后的新值<br><img src="/img/2018/OC/block5.png" alt></li></ol><blockquote><p>注意：<br>1、<strong>全局变量</strong>所占用的内存只有一份,供所有函数共同调用，在Block定义时并未将全局变量的值或者指针传给Block变量所指向的结构体，在Block内访问或修改全局变量和访问上面访问或修改用_block修饰的外部变量效果相同<br>2、<strong>静态变量</strong>在Block定义时将指针传给Block变量所指向的结构体，在Block内访问或修改静态变量和访问上面访问或修改用_block修饰的外部变量效果相同</p></blockquote><h2 id="Block在MRC下的内存管理"><a href="#Block在MRC下的内存管理" class="headerlink" title="Block在MRC下的内存管理"></a>Block在MRC下的内存管理</h2><p>创建一个Student类<br><img src="/img/2018/OC/block_student.png" alt></p><ol><li><p>默认情况下,Block的内存存储在栈中,不需要开发人员对其进行内存管理</p><pre><code>// 当Block变量出了作用域，Block的内存会被自动释放void(^myBlock)() = ^{    NSLog(@&quot;Hello，World!&quot;);};myBlock();</code></pre></li><li><p>在Block的内存存储在栈中时，如果在Block中引用了外面的对象，不会对所引用的对象进行任何操作<br><img src="/img/2018/OC/block6.png" alt></p></li><li><p>如果对Block进行一次copy操作，那么Block的内存会被移动到堆中，这时需要开发人员对其进行release操作来管理内存</p><pre><code>void(^myBlock)() = ^{    NSLog(@&quot;Hello，World!&quot;);};myBlock();Block_copy(myBlock);// do something ...Block_release(myBlock);</code></pre></li><li><p>如果对Block进行一次copy操作，那么Block的内存会被移动到堆中，如果Block中引用了外面的对象,会对所引用的对象进行一次retain操作，那么即使在Block自身调用了release操作之后，Block也不会对所引用的对象进行一次release操作，这时会造成内存泄漏<br><img src="/img/2018/OC/block7.png" alt></p></li><li>如果对Block进行一次copy操作，在Block中引用了外面的对象，如果不想对所引用的对象进行一次retain操作，可以在对象的前面使用__block修饰，避免内存泄漏<br><img src="/img/2018/OC/block8.png" alt></li><li>如果对象内部有一个Block属性，而在Block内部又访问了该对象，那么会造成循环引用<br>情况一<br><img src="/img/2018/OC/block9.png" alt><br>情况二<br><img src="/img/2018/OC/block10.png" alt></li><li>如果对象内部有一个Block属性，而在Block内部又访问了该对象，为了避免造成循环引用，可以在对象的前面用__block修饰，避免Block对对象进行retain操作<br>情况一<br><img src="/img/2018/OC/block11.png" alt><br>情况二<br><img src="/img/2018/OC/block12.png" alt></li></ol><h2 id="Block在ARC下的内存管理"><a href="#Block在ARC下的内存管理" class="headerlink" title="Block在ARC下的内存管理"></a>Block在ARC下的内存管理</h2><p>在 ARC 情况下，只有 NSConcreteGlobalBlock 和 NSConcreteMallocBlock 类型的 block。原本的 NSConcreteStackBlock（存储在栈中） 类型的 block 被 NSConcreteMallocBlock（存储在堆中） 类型的 block 所替代，ARC会自动进行内存管理，程序员只需要避免循环引用即可。在苹果的 <a href="https://developer.apple.com/library/content/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html" target="_blank" rel="noopener">官方文档</a> 中也提到，当把栈中的 block 返回时，不需要调用 copy 方法了。<br><img src="/img/2018/OC/block13.png" alt><br><strong>创建一个Student类</strong></p><pre><code>#import &lt;Foundation/Foundation.h&gt;@interface Student : NSObject/**ARC中的block属性用不用copy修饰都可以，默认会把block拷贝到堆区，为了明显起见，一般写上*/@property (nonatomic, copy) void(^block)(void);@end@implementation Student- (void)dealloc{    NSLog(@&quot;%@---dealloc&quot;,self.class);}@end</code></pre><h3 id="默认情况"><a href="#默认情况" class="headerlink" title="默认情况"></a>默认情况</h3><p>在ARC中Block默认存储在堆中，如果在Block中引用了外面的对象，会对所引用的对象进行强引用，但是在Block被释放时会自动去掉对该对象的强引用,所以不会造成内存泄漏<br><img src="/img/2018/OC/block14.png" alt></p><h3 id="循环引用的情况"><a href="#循环引用的情况" class="headerlink" title="循环引用的情况"></a>循环引用的情况</h3><p><img src="/img/2018/OC/block15.png" alt></p><h3 id="解决循环引用的方案之-block"><a href="#解决循环引用的方案之-block" class="headerlink" title="解决循环引用的方案之__block"></a>解决循环引用的方案之__block</h3><p>在MRC中解决循环引用的办法是在需要引用的变量前使用<strong>block修饰，禁止Block对所引用的对象进行retain操作，但是该方法在ARC下行不通，因为在ARC中</strong>block并不能禁止Block对所引用的变量进行强引用，但是为了可以修改该变量，又不得不利用__block进行修饰，解决办法可以是在Block中将变量置空<br><img src="/img/2018/OC/block16.png" alt></p><h3 id="解决循环引用的方案之-weak"><a href="#解决循环引用的方案之-weak" class="headerlink" title="解决循环引用的方案之__weak"></a>解决循环引用的方案之__weak</h3><p>上述方案确实可以解决循环引用问题，但是在ARC中还有一个更优雅的解决办法，新创建一个弱指针指向需要在Block中进行引用的对象，然后在Block中引用该弱指针对象，这样便避免了循环引用的问题<br><img src="/img/2018/OC/block17.png" alt><br>此时虽然解决了循环引用问题，但同时也引出了一个新问题，那就是由于Block中引用的变量是弱指针指向的，随时都可能释放，有可能在Block中的逻辑执行完之前该对象便已经被释放了，所以我们需要在Block内部再定义一个强指针来指向该对象<br><img src="/img/2018/OC/block18.png" alt></p><h3 id="block关键字在MRC和ARC下的不同"><a href="#block关键字在MRC和ARC下的不同" class="headerlink" title="__block关键字在MRC和ARC下的不同"></a>__block关键字在MRC和ARC下的不同</h3><pre><code>__block在MRC下有两个作用1. 允许在Block中访问和修改局部变量 2. 禁止Block对所引用的对象进行隐式retain操作__block在ARC下只有一个作用1. 允许在Block中访问和修改局部变量</code></pre><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Blocks/Articles/00_Introduction.html#//apple_ref/doc/uid/TP40007502" target="_blank" rel="noopener">Blocks Programming Topics</a><br>[2] <a href="https://developer.apple.com/library/content/featuredarticles/Short_Practical_Guide_Blocks/index.html#//apple_ref/doc/uid/TP40009758" target="_blank" rel="noopener">A Short Practical Guide to Blocks</a><br>[3] <a href="https://developer.apple.com/library/content/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html" target="_blank" rel="noopener">Transitioning to ARC Release Notes</a><br>[4] <a href="http://blog.devtang.com/2013/07/28/a-look-inside-blocks/" target="_blank" rel="noopener">谈Objective-C block的实现</a><br>[5] <a href="https://www.jianshu.com/p/14efa33b3562" target="_blank" rel="noopener">一篇文章看懂iOS代码块Block</a><br>[6] <a href="http://blog.csdn.net/richard_rufeng/article/details/42495169" target="_blank" rel="noopener">Block存储域</a><br>[7] <a href="https://www.jianshu.com/p/a11337dbc8fd" target="_blank" rel="noopener">我所理解的Block：3、Block的存储区域</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/img/2018/OC/block.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;闭包是一个函数（或指向函数的指针），
      
    
    </summary>
    
      <category term="iOS" scheme="http://blog.astudyer.com/categories/iOS/"/>
    
    
      <category term="Objective-C" scheme="http://blog.astudyer.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>OC语言系列——内存管理</title>
    <link href="http://blog.astudyer.com/iOS/OC%E5%9F%BA%E7%A1%80/OC%E8%AF%AD%E8%A8%80%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"/>
    <id>http://blog.astudyer.com/iOS/OC基础/OC语言系列——内存管理.html</id>
    <published>2018-01-14T07:57:31.000Z</published>
    <updated>2020-09-14T01:44:08.312Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/2018/OC/logo.jpg" alt></p><h1 id="MRC内存管理"><a href="#MRC内存管理" class="headerlink" title="MRC内存管理"></a>MRC内存管理</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>自动引用计数（ARC）是在MacOS X 10.7与iOS 5中引入一项新技术，用于代替之前的手动引用计数MRC（Manual Reference Counting）管理Objective-C中的对象【官方也叫MRR（Manual Retain Release）】。如今，ARC下的iOS项目几乎把所有内存管理事宜都交给编译器来决定，而开发者只需专注于业务逻辑。<br>但是，对于iOS开发来说，内存管理是个很重要的概念，如果想要写出内存使用效率高而又没有bug的代码，就得掌握其内存管理模型的细节。</p><blockquote><p><strong>如何在开启MRC环境</strong>：<br>1、整个项目改为MRC：<code>Building Settings</code>-&gt;<code>Objective-C Automatic Reference Counting</code>设置为<code>NO</code><br>2、某个文件改为MRC：<code>Build Phases</code>-&gt;<code>Compile Sources</code>双击需要修改为MRC的文件在弹出的输入框中输入<code>-fno-objc-arc</code><br><strong>MRC转ARC</strong>：<br>选中需要被转换为ARC的文件，然后选择菜单栏中的<code>Edit</code>-&gt;<code>Convert</code>-&gt;<code>To Objective-C ARC...</code></p></blockquote><p><strong>几个概念</strong>：</p><ul><li>僵尸对象: 所占用的内存已经被回收的对象,僵尸对象不能再使用</li><li>野指针: 指向僵尸对象的指针,给野指针发送消息会报错EXC_BAD_ACCESS错误:访问了一块已经被回收的内存</li><li>空指针: 没有指向任何对象的指针(存储的东西是nil,NULL,0),给空指针发送消息不会报错,系统什么也不会做,所以在对象被释放时将指针设置为nil可以避免野指针错误</li></ul><blockquote><p>默认情况下，Xcode是不会监听僵尸对象的,所以需要我们自己手动开启,开启监听僵尸对象步骤为: <code>Edit Scheme</code>-&gt;<code>Run</code>-&gt;<code>Diagnostics</code>-&gt;<code>Memory Management</code>-&gt;<code>Zombie Objects</code>打钩,这样便可以在因为僵尸对象报错的时候给出更多错误信息</p></blockquote><p>示例：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person *p = [[Person alloc] init]; <span class="comment">// 引用计数器 = 1</span></span><br><span class="line">[p release]; <span class="comment">// 引用计数器 = 0,指针所指向的对象的内存被释放</span></span><br><span class="line">[p release]; <span class="comment">// 这句向一块已经被释放的内存发送release消息，会报野指针错误,开启监听僵尸对象会给出错误信息-[Person release]: message sent to deallocated instance 0x100206fd0</span></span><br></pre></td></tr></table></figure></p><blockquote><p>注: 如果在第一次给对象发送release消息后，立刻将指针置空，便不会出现野指针错误，因为给空指针发送消息不会报错，系统什么也不会做，所以在对象被释放时将指针设置为nil可以避免野指针错误</p></blockquote><h2 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h2><p>任何继承了NSObject的对象，对基本数据类型无效</p><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><h3 id="引用计数介绍"><a href="#引用计数介绍" class="headerlink" title="引用计数介绍"></a>引用计数介绍</h3><p>引用计数（Reference Count），也叫保留计数（retain count），表示对象被引用的次数。一个简单而有效的管理对象生命周期的方式。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul><li>当使用<code>alloc</code>、<code>new</code>或者(mutable)<code>copy</code>创建一个对象时，对象的引用计数器被设置为1</li><li>给对象发送一条<code>retain</code>消息，可以使引用计数器值<code>+1</code></li><li>给对象发送一条<code>release</code>消息，可以使引用计数器值<code>-1</code></li><li>当一个对象的引用计数器值为<code>0</code>时，说明这个对象不再被任何对象(指针)指向(引用)了,那么它将会被销毁，其占用的内存被系统回收，OC会自动向该对象发送一条<code>dealloc</code>消息。</li></ul><p>流程参考图如下：<br><img src="/img/2018/OC/mrc.png" alt></p><h3 id="操作引用计数的方法"><a href="#操作引用计数的方法" class="headerlink" title="操作引用计数的方法"></a>操作引用计数的方法</h3><p>以下是NSObject协议中声明的3个用于操作计数器的方法：</p><ul><li><code>retain</code>：引用计数<code>+1</code></li><li><code>release</code>：引用计数<code>-1</code></li><li><code>autorelease</code>：稍后(清理<code>自动释放池</code>时)，再使引用计数<code>-1</code>，所以作用是延迟对象的release</li><li><code>retainCount</code>：给对象发送该消息可以获取对象当前的引用计数值</li></ul><h3 id="dealloc方法"><a href="#dealloc方法" class="headerlink" title="dealloc方法"></a>dealloc方法</h3><p>当引用计数为0的时候对象会自动收到一条dealloc消息。而我们可以在dealloc方法做的，就是释放对其他对象的引用，以及取消已经订阅的KVO、通知等，相当于对象的<code>遗言</code>，在<code>死</code>之前有什么想说的都赶紧说完；（<code>注意点</code>：我们不能手动给对象发送dealloc消息，因为一旦调用dealloc方法，对象就不再有效）</p><h2 id="内存管理原则"><a href="#内存管理原则" class="headerlink" title="内存管理原则"></a>内存管理原则</h2><ol><li>谁创建，谁释放。如果你通过<code>alloc</code>、<code>new</code>或(<code>mutable</code>)copy创建一个对象，那么你必须调用<code>release</code>或<code>autorelease</code>。换句话说，不是你创建的，不需要你去释放</li><li>一般来说，除了<code>alloc</code>、<code>new</code>或(<code>mutable</code>)copy之外的方法创建的对象都声明了<code>autorelease</code></li><li>谁retain，谁release。只要你调用了retain，无论这个对象是如何生成的，你都要调用release</li></ol><blockquote><p>1、对已经释放的对象发送<code>release</code>消息，会产生<code>野指针</code>错误（<code>EXC_BAD_ACCESS</code>）<br>2、对<code>nil</code>发送<code>release</code>消息，不会报错（和<code>野指针</code>有本质区别，<code>nil</code>指的是不指向任何存储空间的指针，并不是野指针，而野指针错误指的是对已经被系统回收的存储空间发送release消息）<br>3、<code>autorelease</code>：在适当的时刻自动使引用计数器<code>-1</code>（注意：不一定是释放）</p></blockquote><h2 id="property参数详解"><a href="#property参数详解" class="headerlink" title="@property参数详解"></a>@property参数详解</h2><h3 id="retain"><a href="#retain" class="headerlink" title="retain"></a>retain</h3><p><strong>含义</strong>：在setter方法中release旧值，retain新值<br><strong>示例</strong>：<code>@proterty (retain) Book *book;</code>编译器编译到这句代码会自动帮我们实现如下形式的setter方法<br>    <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setBook:(Book *)book&#123;</span><br><span class="line"><span class="keyword">if</span> (_book != book) &#123;</span><br><span class="line">  [_book release];</span><br><span class="line">   [_book <span class="keyword">retain</span>];</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h3><p><code>默认类型</code>，setter方法直接赋值，而不进行retain操作，不会改变引用计数，写不写都一样，一般用于基本数据类型</p><h3 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h3><p><strong>含义</strong>：编译器只会帮我们生成get方法的声明（我们依然可以手动实现set方法的声明）<br><strong>默认值</strong>：readwrite（同时生成get和set方法的声明）</p><h3 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h3><ul><li>@property属性<code>默认为atomic</code>，提供多线程安全</li><li>在多线程环境下，原子操作是必要的，否则有可能引起错误的结果</li><li>加了atomic，setter/getter是一个原子操作。如果多个线程同时调用setter的话，不会出现某一个线程执行完setter全部语句之前，另一个线程开始执行setter的情况，相当于函数头尾加了锁一样</li><li>加了atomic，setter函数会变成下面这样：  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;lock&#125;</span><br><span class="line"><span class="keyword">if</span> (property != newValue) &#123; </span><br><span class="line">[property release]; </span><br><span class="line">property = [newValue <span class="keyword">retain</span>]; </span><br><span class="line">&#125;</span><br><span class="line">&#123;unlock&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="nonatomic"><a href="#nonatomic" class="headerlink" title="nonatomic"></a>nonatomic</h3><ul><li>禁止多线程，变量保护，提高性能</li><li>atomic是OC使用的一种线程保护技术，防止在写入未完成的时候被另外一个线程读取，造成数据错误。而这种机制是耗费系统资源的，所以在iPhone这种小型设备上，如果没有使用多线程间的通讯编程，那么nonatomic是一个非常好的选择</li><li>如果不需要多线程支持的话，用nonatomic就够了，另外由于不涉及锁操作，所以执行速度相对快点</li></ul><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p><strong>含义</strong>：setter方法release旧值，再copy新值</p><h3 id="getter"><a href="#getter" class="headerlink" title="getter"></a>getter</h3><p><strong>含义</strong>：指定getter方法的方法名，一般用于BOOL值</p><h2 id="自动释放池（autorelease-pool）"><a href="#自动释放池（autorelease-pool）" class="headerlink" title="自动释放池（autorelease pool）"></a>自动释放池（autorelease pool）</h2><p><strong>创建</strong>：<code>NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];</code><br><strong>释放</strong>：<code>[pool release]</code> 或者 <code>[pool drain]</code>;</p><ul><li>自动释放池是OC里面的一种内存自动回收机制，一般可以将一些临时变量添加到自动释放池中，统一回收释放</li><li>当自动释放池销毁时，池里面的所有对象都会调用一次release方法</li><li>OC对象只需要发送一条autorelease消息，就会把这个对象添加到最近的自动释放池中（栈顶的释放池）（<code>注意：该操作不会改变引用计数</code>）</li><li>autorelease实际上只是把对release的调用延迟了，对于每一次autorelease，系统只是把该对象放入了当前的autorelease pool中，当该pool被释放时，该pool中的所有对象都会被调用release（<code>注意：该操作不一定能释放掉对象</code>）</li></ul><p><strong>释放时机</strong><br>每个Runloop中都创建一个autorelease pool（自动释放池），并在Runloop的末尾进行释放，而当该pool被释放时，该pool中的所有Object会接收到一个release消息。 所以，一般情况下，每个接受autorelease消息的对象，都会在下个Runloop开始前被释放。<br><strong>注意点</strong></p><ol><li>在ARC下，不能使用<code>[[NSAutoreleasePool alloc] init]</code>，而应当使用<code>@autoreleasepool{}</code>创建自动释放池</li><li>不要把大量循环操作放到同一个NSAutoreleasePool之间，这样会造成内存峰值的上升（此时应该手动调用release方法或者手动创建自动释放池，自己管理内存）</li><li>尽量避免对大内存使用该方法，对于这种延迟释放机制，还是尽量少用</li><li>SDK中一般利用静态方法创建并返回的对象都是autorelease的，不需要再进行release操作<br> 如[NSNumber numberWithInt:10];返回的对象是不需要再release的。<br> 但是通过[[NSNumber alloc] initWithInt:10];创建的对象需要release</li></ol><h1 id="ARC内存管理"><a href="#ARC内存管理" class="headerlink" title="ARC内存管理"></a>ARC内存管理</h1><h2 id="ARC简介"><a href="#ARC简介" class="headerlink" title="ARC简介"></a>ARC简介</h2><p>ARC自动引用计数（automatic reference counting）是iOS5推出的新功能。需要注意的是，ARC并不是GC（Garbage Collection 垃圾回收器），仍然是需要用引用计数管理内存的，只不过是隐式的管理。它背后依赖的是编译器的静态分析能力，通过在编译时在合适的位置插入引用计数管理代码，从而提高iOS开发人员的开发效率。是<code>编译器特性</code>，并不是OC的运行时特性。</p><blockquote><p>在ARC中栈变量会被初始化为nil，即使不进行赋值,程序也不会造成崩溃,示例如下<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)test &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *name;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"name: %@"</span>, name);</span><br><span class="line">    <span class="comment">// 打印结果为nil,不会崩溃</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="ARC判断标准"><a href="#ARC判断标准" class="headerlink" title="ARC判断标准"></a>ARC判断标准</h2><p>只要有强指针指向一个对象，那个这个对象就不会被释放，只要没有强指针指向一个对象，那么这个对象就被立即回收</p><h2 id="指针分类"><a href="#指针分类" class="headerlink" title="指针分类"></a>指针分类</h2><p>1、<strong>强指针</strong>：默认所有的指针都是强指针，关键字<code>__strong</code><br>2、<strong>弱指针</strong>：一般在两个对象相互引用而导致循环引用无法释放的时候用<code>__weak</code>修饰其中一个对象对另一个对象的应用，避免循环应用</p><h2 id="ARC注意点"><a href="#ARC注意点" class="headerlink" title="ARC注意点"></a>ARC注意点</h2><p>1、不能显示调用release、retain、retainCount、autorelease、zone等消息<br>2、不能再使用NSAutoreleasePool对象，ARC提供了@autoreleasepool块来代替它，这样更有效率<br>3、可以重写dealloc，但是不允许调用<code>[super dealloc];</code><br>4、一般来说用类方法直接创建的对象编译器默认会在后面插入<code>autorelease</code>方法</p><h2 id="property参数"><a href="#property参数" class="headerlink" title="@property参数"></a>@property参数</h2><h3 id="strong"><a href="#strong" class="headerlink" title="strong"></a>strong</h3><p>相当于MRC中的retain（适用于OC对象），对对象进行强引用</p><h3 id="weak"><a href="#weak" class="headerlink" title="weak"></a>weak</h3><p>不改变对象的引用计数，也不持有对象，对对象进行弱引用，比assign多了一个功能，当对象消失后自动把指针变成nil（适用于OC对象）</p><h3 id="assign-1"><a href="#assign-1" class="headerlink" title="assign"></a>assign</h3><p>对对象进行弱引用，和weak类似，适用于非OC对象（基本数据类型）</p><h3 id="copy-1"><a href="#copy-1" class="headerlink" title="copy"></a>copy</h3><p>对于不可变对象来说相当于strong，开辟一块新的内存空间</p><h2 id="关于Copy"><a href="#关于Copy" class="headerlink" title="关于Copy"></a>关于Copy</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>copy(复制、拷贝)是产生一个副本对象的过程,只要是通过拷贝产生的副本对象,副本对象中的内容与源对象中的内容就完全一致</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>修改源对象的属性和行为,不会影响副本对象</li><li>修改副本对象的属性和行为,不会影响源对象</li></ul><h3 id="copy与mutableCopy"><a href="#copy与mutableCopy" class="headerlink" title="copy与mutableCopy"></a>copy与mutableCopy</h3><ul><li>使用copy产生的副本对象是不可变的(如NSString、NSArray)</li><li>使用mutableCopy产生的副本对象是可变的(如NSMutableString、NSMutableArray)</li></ul><h3 id="通过拷贝是否会产生新的对象"><a href="#通过拷贝是否会产生新的对象" class="headerlink" title="通过拷贝是否会产生新的对象"></a>通过拷贝是否会产生新的对象</h3><p>通过拷贝是否会产生新对象,就要看源对象与副本对象是否满足拷贝的特点</p><ul><li>可变对象通过mutableCopy,会生成新的对象</li><li>可变对象通过copy,会生成新的对象</li><li>不可变对象通过mutableCopy,会生成新的对象</li><li>不可变对象通过copy,不会生成新的对象</li></ul><h3 id="深拷贝-内容拷贝-与浅拷贝-指针拷贝"><a href="#深拷贝-内容拷贝-与浅拷贝-指针拷贝" class="headerlink" title="深拷贝(内容拷贝)与浅拷贝(指针拷贝)"></a>深拷贝(内容拷贝)与浅拷贝(指针拷贝)</h3><ul><li>深拷贝: 如果通过拷贝生成了新对象,就称为深拷贝(内容拷贝)</li><li>浅拷贝: 如果通过拷贝没生成新对象,就称为浅拷贝(指针拷贝)</li></ul><blockquote><p>注意：<br>1、通过深拷贝，源对象的引用计数器不变，副本对象的引用计数器为1，所以需要对副本对象进行一次release操作<br>2、通过浅拷贝,源对象的引用计数器+1,所以需要对源对象再进行一次release操作</p></blockquote><h2 id="自定义类实现copy与mutableCopy功能"><a href="#自定义类实现copy与mutableCopy功能" class="headerlink" title="自定义类实现copy与mutableCopy功能"></a>自定义类实现copy与mutableCopy功能</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>一个类的对象想拥有copy与mutableCopy功能，都需要拥有一个前提</p><ul><li>使用copy的前提: 对应类需要遵守NSCopying协议,并实现copyWithZone:方法</li><li>使用mutableCopy的前提: 对应类需要遵守NSMutableCopying协议,并实现mutableCopyWithZone:方法</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person类的copy与mutableCopy功能</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">NSMutableCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.创建一个新对象</span></span><br><span class="line">    Person *p = [[[<span class="keyword">self</span> <span class="keyword">class</span>] allocWithZone:zone] init];</span><br><span class="line">    <span class="comment">// 2.设置当前对象的内容给新的对象</span></span><br><span class="line">    p.name = _name;</span><br><span class="line">    <span class="comment">// 3.返回新的对象</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)mutableCopyWithZone:(<span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// 1.创建一个新对象</span></span><br><span class="line">    Person *p = [[[<span class="keyword">self</span> <span class="keyword">class</span>] allocWithZone:zone] init];</span><br><span class="line">    <span class="comment">// 2.设置当前对象的内容给新的对象</span></span><br><span class="line">    p.name = _name;</span><br><span class="line">    <span class="comment">// 3.返回新的对象</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现Student类(继承自Person类)的copy与mutableCopy功能</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.创建一个新对象</span></span><br><span class="line">    <span class="keyword">id</span> stu = [<span class="keyword">super</span> copyWithZone:zone];</span><br><span class="line">    <span class="comment">// 2.设置当前对象的内容给新的对象</span></span><br><span class="line">    stu.age = _age;</span><br><span class="line">    <span class="comment">// 3.返回新的对象</span></span><br><span class="line">    <span class="keyword">return</span> stu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)mutableCopyWithZone:(<span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// 1.创建一个新对象</span></span><br><span class="line">    <span class="keyword">id</span> stu = [<span class="keyword">super</span> mutableCopyWithZone:zone];</span><br><span class="line">    <span class="comment">// 2.设置当前对象的内容给新的对象</span></span><br><span class="line">    stu.age = _age;</span><br><span class="line">    <span class="comment">// 3.返回新的对象</span></span><br><span class="line">    <span class="keyword">return</span> stu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="几个经典面试题"><a href="#几个经典面试题" class="headerlink" title="几个经典面试题"></a>几个经典面试题</h2><p>1、在ARC中以下代码有没有问题？如果有问题，怎么写才正确？<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="built_in">NSIntegerMax</span>; i++) &#123;</span><br><span class="line">   [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>,<span class="string">@"哈哈"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于stringWithFormat创建出来的对象调用了autorelease方法，所以不会立即释放，创建出来的大量对象一直在内存中，会导致内存在短时间内暴涨。所以有问题。正确的写法如下<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="built_in">NSIntegerMax</span>; i++) &#123;</span><br><span class="line">   <span class="keyword">@autoreleasepool</span>&#123;</span><br><span class="line">       [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>,<span class="string">@"哈哈"</span>];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、strong和weak作为属性修饰符的区别？<br>都指向原来数据地址，区别是前者会对数据地址进行引用计数+1，后者不会<br>3、assing和weak作为属性修饰符的区别？<br>assign和weak都指向引用对象地址并且计数不+1，但当对象地址引用计数为0时，assign不会对该地址进行数据的抹除操作，只是进行值释放。容易导致野指针现象（指针还在，指针指向的内存已经释放，访问不属于自己的内存），即当这块地址还没写上其他值前，能输出正常值，但一旦重新写上数据，该指针随时可能没有值，造成奔溃。而weak会在对象消失（引用计数为0）时自动把指针变成nil，防止野指针问题。一般assign常用语基本数据类型，而weak用于OC对象（基于NSObject的对象）。<br>4、copy与retain作为属性修饰符的区别？</p><ul><li>通过copy作为属性修饰符来修饰对象的属性，是对传入变量进行了一次copy操作，在外界变量进行修改之后，对象的属性不会随之发生变化</li><li>通过retain作为属性修饰符来修饰对象的属性,是对传入变量进行了一次retain操作,在外界变量进行修改之后,对象的属性会随之发生了变化</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/img/2018/OC/logo.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;MRC内存管理&quot;&gt;&lt;a href=&quot;#MRC内存管理&quot; class=&quot;headerlink&quot; title=&quot;MRC内存管理&quot;&gt;&lt;/a&gt;MRC内存管理&lt;/h1&gt;&lt;h2 id=&quot;
      
    
    </summary>
    
      <category term="iOS" scheme="http://blog.astudyer.com/categories/iOS/"/>
    
    
      <category term="Objective-C" scheme="http://blog.astudyer.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>OC语言系列——Protocol(协议)及Delegate(委托代理)</title>
    <link href="http://blog.astudyer.com/iOS/OC%E5%9F%BA%E7%A1%80/OC%E8%AF%AD%E8%A8%80%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94Protocol(%E5%8D%8F%E8%AE%AE)%E5%8F%8ADelegate(%E5%A7%94%E6%89%98%E4%BB%A3%E7%90%86).html"/>
    <id>http://blog.astudyer.com/iOS/OC基础/OC语言系列——Protocol(协议)及Delegate(委托代理).html</id>
    <published>2018-01-14T07:57:31.000Z</published>
    <updated>2020-09-14T01:44:08.312Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/2018/OC/logo.jpg" alt><br>因为Objective-C是不支持多继承的，所以很多时候都是用Protocol代替。Protocol（协议）只是定义公用的一套接口，但不提供具体的实现方法。当一个类要使用某个Protocol（协议）时，就必须要遵守协议，实现协议需要用到委托代理（Delegate）。<br>Protocol（协议）的作用：</p><ol><li><p>定义一套公用的接口（Public）</p><ul><li>@required：必须实现的方法（实际上也可以不实现，程序依然也可以运行，只是会有警告）</li><li><p>@optional：可选 实现的方法</p><pre><code>//conformsToProtocol：判断是否遵守了某个协议if ([conformsToProtocol:@protocol(协议名)]){}//respondsToSelector：判断是否实现了某个方法if([stu respondsToSelector:@selector(方法名)]){}</code></pre></li></ul></li><li><p>委托代理（Delegate）传值：<br>它本身是一个设计模式，它的意思是委托别人去做某事。 </p></li></ol><blockquote><p>1、当需要定义一套公用的接口，实现方法可以是不同的时候，可以使用Protocol协议。<br>2、当需要进行类与类之间的传值时，可以基于Protocol协议，使用代理设计模式进行传值。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/img/2018/OC/logo.jpg&quot; alt&gt;&lt;br&gt;因为Objective-C是不支持多继承的，所以很多时候都是用Protocol代替。Protocol（协议）只是定义公用的一套接口，但不提供具体的实现方法。当一个类要使用某个Protocol（
      
    
    </summary>
    
      <category term="iOS" scheme="http://blog.astudyer.com/categories/iOS/"/>
    
    
      <category term="Objective-C" scheme="http://blog.astudyer.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>OC语言系列——基础篇</title>
    <link href="http://blog.astudyer.com/iOS/OC%E5%9F%BA%E7%A1%80/OC%E8%AF%AD%E8%A8%80%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87.html"/>
    <id>http://blog.astudyer.com/iOS/OC基础/OC语言系列——基础篇.html</id>
    <published>2018-01-14T03:39:06.000Z</published>
    <updated>2020-09-14T01:44:08.312Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/2018/OC/logo.jpg" alt>    </p><h2 id="面向对象性"><a href="#面向对象性" class="headerlink" title="面向对象性"></a>面向对象性</h2><p>OC语言是面对对象的</p><h2 id="关于类"><a href="#关于类" class="headerlink" title="关于类"></a>关于类</h2><p>OC中类的设计包括三个方面：类名、类的属性和方法</p><h2 id="关于对象"><a href="#关于对象" class="headerlink" title="关于对象"></a>关于对象</h2><p>每个对象内部都默认有一个隐藏的isa指针指向这个对象所使用的类<br><code>创建过程</code>：调用alloc方法在内存中为对象开辟一块内存空间，调用init方法进行初始化，每个对象都有一份属于自己的单独的成员变量，所有的对象公用类的成员方法，方法在整个内存中只有一份，类本身在内存中占据一份存储空间，类的方法存储于此。</p><h2 id="消息机制"><a href="#消息机制" class="headerlink" title="消息机制"></a>消息机制</h2><p>在OC中，对象对方法的调用称为消息机制，即向既定的对象发送了什么消息。<br><code>[p eat];</code>表示给p所指向的对象发送一条eat消息，调用对象的eat方法，此时对象会顺着内部的isa指针找到存储于类中的方法(先去缓存中去取，缓存中没有再去类的内存中找)，执行。<br><code>点语法的本质</code>：调用属性的setter和getter方法</p><h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p><strong>@public</strong>：全局可以访问<br><strong>@protected</strong>：只能在类内部和子类中访问<br><strong>@private</strong>：只能在类内部访问</p><blockquote><p>注意：<code>.h</code>中的成员变量的默认作用域是<code>@protected</code><br><code>.m</code>中的成员变量不管作用域写为什么，子类都不能访问，即被强制为<code>@private</code></p></blockquote><h2 id="property关键字"><a href="#property关键字" class="headerlink" title="@property关键字"></a>@property关键字</h2><ul><li><p>在xcode4.5之前，可以让编译器自动生成属性的setter和getter方法的<code>声明</code></p><pre><code>@proterty int age;// 等价于下面2行- (void)setAge:(int)newAge;// setter- (int)age;    // getter</code></pre></li><li><p>在xcode4.5(包括)之后，可以让编译器自动生成属性的setter和getter方法的<code>声明</code>和<code>实现</code>(会访问带下划线的同名的成员变量，如果没有则自动创建一个带下划线的同名的私有成员变量，并为该变量生成getter和setter方法)</p><pre><code>@proterty int age;// 等价于下面8行- (void)setAge:(int)newAge;// setter声明- (int)age;    // getter声明- (void)setAge:(int)newAge{// setter实现    _age = newAge;}- (int)age{// getter实现    return _age;}        </code></pre></li></ul><h2 id="synthesize关键字"><a href="#synthesize关键字" class="headerlink" title="@synthesize关键字"></a>@synthesize关键字</h2><p><strong>示例用法</strong>：<code>@synthesize name = _goodName;</code><br><strong>默认情况</strong>：<code>@synthesize name;</code>等价于<code>@synthesize name = _name;</code><br>让编译器自动生成同名属性<code>name</code>的setter和getter方法的<code>声明</code>和<code>实现</code>，并访问成员变量<code>_goodName</code>，如果没有则创建一个私有成员变量<code>_goodName</code>，默认情况访问成员变量<code>_name</code>;</p><pre><code>@synthesize age;// 等价于下面6行- (void)setAge:(int)newAge{// setter实现    _age = newAge;}- (int)age{// getter实现    return _age;}@synthesize age = _goodName;// 等价于下面6行- (void)setAge:(int)newAge{// setter实现    _goodName = newAge;}- (int)age{// getter实现    return _goodName;}</code></pre><blockquote><p><strong>注意</strong>：<br>1、如果实现自定义的setter方法，@property就不会帮我们生成它的setter方法，但仍然会帮我们生成getter方法和私有的成员变量<br>2、如果实现自定义的getter方法，@property就不会帮我们生成它的getter方法，但仍然会帮我们生成setter方法和私有的成员变量<br>3、如果你实现了setter和getter方法，@property就不会帮我们生成它的setter和getter方法，同时也不会生成私有成员变量了，需要自己手动添加该成员变量或者手动实现@synthesize name = _name方法。</p></blockquote><h2 id="关于self"><a href="#关于self" class="headerlink" title="关于self"></a>关于self</h2><p><strong>在对象方法中使用</strong>：指的是该对象<br><strong>在类方法中使用</strong>：指的是该类本身</p><h2 id="成员变量和属性的区别"><a href="#成员变量和属性的区别" class="headerlink" title="成员变量和属性的区别"></a>成员变量和属性的区别</h2><p>操作成员变量需要用<code>-&gt;</code>，@property生成属性仅仅是帮我们自动生成了私有成员变量和set和get方法，而set和get方法本质还是操作成员变量，而属性则可以让我们方便的用点语法访问该属性（本质也就是操作成员变量），@synthesize则可以通过@synthesize name = alias_name的方式改变set和get方法操作的具体成员变量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/img/2018/OC/logo.jpg&quot; alt&gt;    &lt;/p&gt;
&lt;h2 id=&quot;面向对象性&quot;&gt;&lt;a href=&quot;#面向对象性&quot; class=&quot;headerlink&quot; title=&quot;面向对象性&quot;&gt;&lt;/a&gt;面向对象性&lt;/h2&gt;&lt;p&gt;OC语言是面对对象
      
    
    </summary>
    
      <category term="iOS" scheme="http://blog.astudyer.com/categories/iOS/"/>
    
    
      <category term="Objective-C" scheme="http://blog.astudyer.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>CocoaPods的安装和使用</title>
    <link href="http://blog.astudyer.com/%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87/%E7%BB%84%E4%BB%B6%E5%8C%96/CocoaPods%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8.html"/>
    <id>http://blog.astudyer.com/开发必备/组件化/CocoaPods的安装和使用.html</id>
    <published>2018-01-12T00:56:42.000Z</published>
    <updated>2020-09-14T01:44:08.315Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/2018/Tools/cocoapods.jpg" alt></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="什么是CocoaPods"><a href="#什么是CocoaPods" class="headerlink" title="什么是CocoaPods"></a>什么是<a href="https://cocoapods.org" target="_blank" rel="noopener">CocoaPods</a></h3><p>CocoaPods是OS X和iOS下的一个第三类库管理工具，是一个用Ruby写的、负责管理iOS项目中第三方开源库的工具。通过CocoaPods工具我们可以为项目添加被称为“Pods”的依赖库（这些类库必须是CocoaPods本身所支持的），并且可以轻松管理其版本。</p><h3 id="为什么要使用CocoaPods"><a href="#为什么要使用CocoaPods" class="headerlink" title="为什么要使用CocoaPods"></a>为什么要使用CocoaPods</h3><p>使用CocoaPods可以让我们能自动化的、集中的、直观的管理第三方开源库，为我们节省配置和更新第三方开源库的时间。</p><ol><li>在引入第三方库时它可以自动为我们完成各种各样的配置，包括配置编译阶段、连接器选项、甚至是ARC环境下的-fno-objc-arc配置等。</li><li>使用CocoaPods可以很方便地查找新的第三方库，这些类库是比较“标准的”，而不是网上随便找到的，这样可以让我们找到真正好用的类库。</li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>CocoaPods是用Ruby实现的，使用它首先需要有Ruby环境。不过幸运的是Mac系统自带Ruby环境，所以我们可以直接在终端使用以下命令进行安装:</p><blockquote><p>sudo gem install cocoapods</p></blockquote><p>安装完成之后执行<strong><code>pod setup</code></strong>指令初始化本地索引库，需要注意的是此过程可能比较漫长(视网速而定)，需要耐心等待，不要以为界面卡死。</p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>只需要再次执行<code>sudo gem install cocoapods</code>命令即可以更新cocoapods</p><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><blockquote><p>sudo gem uninstall cocoapods</p></blockquote><h2 id="安装过程中出现的问题及解决方案"><a href="#安装过程中出现的问题及解决方案" class="headerlink" title="安装过程中出现的问题及解决方案"></a>安装过程中出现的问题及解决方案</h2><h3 id="执行完install命令后半天没反应"><a href="#执行完install命令后半天没反应" class="headerlink" title="执行完install命令后半天没反应"></a>执行完install命令后半天没反应</h3><p>原因：ruby源被墙(笔者用的是默认的ruby源也没有翻墙，并没有遇到这种情况)<br>解决方案：<strong>更换ruby源</strong>（把源切换至ruby-china，网上好多方案是使用淘宝的<code>https://ruby.taobao.org/</code>，这里笔者不再建议使用了，这是因为淘宝的ruby源已停止维护，现由ruby-china提供镜像服务）</p><ul><li>查看当前的ruby源（一般默认是<code>https://rubygems.org/</code>）：<code>gem sources -l</code></li><li>删除默认ruby源：<code>gem sources --remove https://rubygems.org/</code></li><li>添加新的ruby源：<code>gem sources --add https://gems.ruby-china.org/</code></li></ul><p>执行完以上命令可以再次执行<code>gem sources -l</code>查看结果是否是且仅是<code>https://gems.ruby-china.org/</code>进行验证，如果显示以下结果，则说明ruby源已经更换成功</p><pre><code>*** CURRENT SOURCES ***https://gems.ruby-china.org/</code></pre><h3 id="安装完成之后执行pod-search找不到第三方库"><a href="#安装完成之后执行pod-search找不到第三方库" class="headerlink" title="安装完成之后执行pod search找不到第三方库"></a>安装完成之后执行<strong><code>pod search</code></strong>找不到第三方库</h3><p>解决方案：删除cocoapods的索引，然后重新search(触发cocoapods重新拉这个索引文件)<br>在终端执行命令<strong><code>rm ~/Library/Caches/CocoaPods/search_index.json</code></strong></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="搜索你想要的库"><a href="#搜索你想要的库" class="headerlink" title="搜索你想要的库"></a>搜索你想要的库</h3><p><code>pod search 库的名字</code></p><h3 id="在项目根目录创建Podfile文件"><a href="#在项目根目录创建Podfile文件" class="headerlink" title="在项目根目录创建Podfile文件"></a>在项目根目录创建Podfile文件</h3><h3 id="在Podfile文件中添加以下内容"><a href="#在Podfile文件中添加以下内容" class="headerlink" title="在Podfile文件中添加以下内容"></a>在Podfile文件中添加以下内容</h3><pre><code>platform :ios, &apos;8.0&apos;use_frameworks!target &apos;MyApp&apos; do  pod &apos;AFNetworking&apos;, &apos;~&gt; 2.6&apos;#你想要用cocoapods管理的第三方库及其版本  pod &apos;SDWebImage&apos;, &apos;~&gt; 3.0&apos;end</code></pre><h3 id="执行pod-install命令自动集成第三方库"><a href="#执行pod-install命令自动集成第三方库" class="headerlink" title="执行pod install命令自动集成第三方库"></a>执行<code>pod install</code>命令自动集成第三方库</h3><p>如果出现下图字样，证明集成成功，这时候会在你的项目根目录下生成一个<strong>.xcworkspace</strong>文件。只需要关闭当前的<strong>.xcodeproj</strong>，打开新生成的<strong>.xcworkspace</strong>即可使用集成好的第三方库。<br><img src="/img/2018/Tools/cocoapods_success.png" alt></p><h3 id="更新第三方库"><a href="#更新第三方库" class="headerlink" title="更新第三方库"></a>更新第三方库</h3><p>只需要执行<strong><code>pod update</code></strong>命令即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/img/2018/Tools/cocoapods.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;h3 id=&quot;什么是CocoaPods
      
    
    </summary>
    
      <category term="开发必备" scheme="http://blog.astudyer.com/categories/%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87/"/>
    
    
      <category term="CocoaPods" scheme="http://blog.astudyer.com/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>第三方库踩坑系列</title>
    <link href="http://blog.astudyer.com/iOS/%E5%85%B6%E5%AE%83/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E8%B8%A9%E5%9D%91%E7%B3%BB%E5%88%97.html"/>
    <id>http://blog.astudyer.com/iOS/其它/第三方库踩坑系列.html</id>
    <published>2018-01-12T00:43:27.000Z</published>
    <updated>2020-09-14T01:44:08.314Z</updated>
    
    <content type="html"><![CDATA[<p><strong>坑是无限的，而生命是有限的，坑虽多，但在我们的努力下终归会越踩越少。所以我们的格言就是：生命不息，踩坑不止。</strong><br><img src="/img/2018/iOS/caikeng.jpg" alt></p><h2 id="IQKeyboardManager"><a href="#IQKeyboardManager" class="headerlink" title="IQKeyboardManager"></a><a href="https://github.com/hackiftekhar/IQKeyboardManager" target="_blank" rel="noopener">IQKeyboardManager</a></h2><p>笔者所用<strong>版本</strong>：4.0.13<br>出现的<strong>问题</strong>：每次打开项目项目都会自动断在如下图所示的地方<br><img src="/img/2018/iOS/IQKeyBoardManager1.png" alt><br><strong>解决方案</strong>：编辑<code>All Exceptions</code>这个断点，把<code>Exception</code>那一栏由<code>All</code>改为<code>Objective-C</code>即可<br>注意：如果没有<code>All Exceptions</code>这个断点，则不会出现该情况<br><img src="/img/2018/iOS/IQKeyBoardManager2.png" alt><br><img src="/img/2018/iOS/IQKeyBoardManager3.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;坑是无限的，而生命是有限的，坑虽多，但在我们的努力下终归会越踩越少。所以我们的格言就是：生命不息，踩坑不止。&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;/img/2018/iOS/caikeng.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;IQKeyboa
      
    
    </summary>
    
      <category term="iOS" scheme="http://blog.astudyer.com/categories/iOS/"/>
    
    
      <category term="踩坑" scheme="http://blog.astudyer.com/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>如何在Mac上方便的启用Http Server</title>
    <link href="http://blog.astudyer.com/Server/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%A6%82%E4%BD%95%E5%9C%A8Mac%E4%B8%8A%E6%96%B9%E4%BE%BF%E7%9A%84%E5%90%AF%E7%94%A8Http-Server.html"/>
    <id>http://blog.astudyer.com/Server/服务器/如何在Mac上方便的启用Http-Server.html</id>
    <published>2017-07-26T03:23:46.000Z</published>
    <updated>2020-09-14T01:44:08.314Z</updated>
    
    <content type="html"><![CDATA[<p>我们在本地调试Html或者php等后台程序的时候,经常需要启动一个本地Web服务器,对于不太会配置Apache等服务器的童鞋,我专门写过一篇文章教你<a href="http://localhost:4000/server-side/%E5%A6%82%E4%BD%95%E6%8A%8A%E4%BD%A0%E7%9A%84%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE%E6%88%90%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8.html" target="_blank" rel="noopener">如何把你的电脑配置成本地服务器</a>.</p><p>所谓条条道路通罗马,解决问题的方案永远不止一个,本文就将带你用另一种简洁的方式去解决这个问题.<br><code>在Python或PHP命令行下启用Http Server。</code></p><p>由于在Mac系统下，Python和Php都是默认安装好的，所以不需要额外的软件支持。具体方法如下：</p><h4 id="方法一：不支持PHP"><a href="#方法一：不支持PHP" class="headerlink" title="方法一：不支持PHP"></a>方法一：不支持PHP</h4><p>这一方法的前提是，系统已经默认安装了Python，所以可以利用Python启用Http服务器。 步骤：</p><pre><code>$cd /projectpath$python -m SimpleHTTPServer 9999</code></pre><p>然后，在浏览器输入<code>http://localhost:9999</code>即可,此方法仅适用于提供html等文件服务，不支持运行PHP脚本.</p><h4 id="方法二-支持PHP"><a href="#方法二-支持PHP" class="headerlink" title="方法二:支持PHP"></a>方法二:支持PHP</h4><pre><code>$cd /projectpath$php -S localhost:9999</code></pre><p>然后，在浏览器输入<code>http://localhost:9999</code>即可访问.该方法支持运行PHP脚本.</p><h4 id="停止server"><a href="#停止server" class="headerlink" title="停止server"></a>停止server</h4><p><code>在终端按control+C</code></p><h4 id="其他系统"><a href="#其他系统" class="headerlink" title="其他系统"></a>其他系统</h4><p>由于Python和PHP都是跨平台的，在其他系统上，只需要安装好这两个运行环境，就可以使用同样的方法.</p><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p>以上生成的链接有的端口经过笔者的测试可能无法访问,如果你启动服务器后在浏览器中输入对应的链接发现不可用,可以尝试换一个端口.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们在本地调试Html或者php等后台程序的时候,经常需要启动一个本地Web服务器,对于不太会配置Apache等服务器的童鞋,我专门写过一篇文章教你&lt;a href=&quot;http://localhost:4000/server-side/%E5%A6%82%E4%BD%95%E
      
    
    </summary>
    
      <category term="Server" scheme="http://blog.astudyer.com/categories/Server/"/>
    
    
      <category term="Server" scheme="http://blog.astudyer.com/tags/Server/"/>
    
  </entry>
  
  <entry>
    <title>一台电脑如何绑定多个github账号</title>
    <link href="http://blog.astudyer.com/%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87/%E5%85%B6%E5%AE%83/%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E5%A6%82%E4%BD%95%E7%BB%91%E5%AE%9A%E5%A4%9A%E4%B8%AAgithub%E8%B4%A6%E5%8F%B7.html"/>
    <id>http://blog.astudyer.com/开发必备/其它/一台电脑如何绑定多个github账号.html</id>
    <published>2017-07-24T02:46:48.000Z</published>
    <updated>2020-09-14T01:44:08.314Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么-你还没有一个GitHub账号-😱"><a href="#什么-你还没有一个GitHub账号-😱" class="headerlink" title="什么,你还没有一个GitHub账号?😱"></a>什么,你还没有一个GitHub账号?😱</h3><p>作为一名程序员,我想你大概99.9%的可能听说过<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>.如果把优秀的代码比作美女,那[GitHub]上说是美女云集真是一点也不过分啊!如果你到现在还没有一个github账号.那么兄弟我真的劝你赶紧去<a href="https://github.com/" target="_blank" rel="noopener">注册</a>一个去.</p><h3 id="我不但有-而且不止一个-就是任性😏"><a href="#我不但有-而且不止一个-就是任性😏" class="headerlink" title="我不但有,而且不止一个,就是任性😏"></a>我不但有,而且不止一个,就是任性😏</h3><p>而对于那些经常和github打交道的小伙伴,就好像有的人会有2个QQ号,一个工作时候用,一个私下用一样,部分朋友可能会同时经营着2个GitHub账号.可是申请完第二个账号,还没来得及嘚瑟,这些小伙伴就在使用的时候可能就遇到了当头一棒,那就是两个账号没法在一个电脑上同时操作(指的是用ssh操作,通过https操作的除外),遇到过这个问题的小伙伴都懂的,不再过多解释.</p><h3 id="告诉你一个好消息和一个好消息-你先听哪个-😆"><a href="#告诉你一个好消息和一个好消息-你先听哪个-😆" class="headerlink" title="告诉你一个好消息和一个好消息,你先听哪个?😆"></a>告诉你一个好消息和一个好消息,你先听哪个?😆</h3><p>其实上述问题是有解决方案的,也很简单.接下来就一步步教你如何解决这个问题,愉快的让多个github账号在你的电脑上和谐共存,无不干扰.</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li>首先由2个github账号,假设一个账号为one,另一个账号为two</li><li>取消git全局设置<br><code>$ git config --global --unset user.name</code><br><code>$ git config --global --unset user.email</code></li></ul><h3 id="SSH配置"><a href="#SSH配置" class="headerlink" title="SSH配置"></a>SSH配置</h3><ul><li>生成两对RSA密钥对<br><code>$ ssh-keygen -t rsa -C &quot;你的邮箱&quot;</code><br>如果直接回车,会默认放在~/.ssh目录下,并且命名为id_rsa(私钥)和id_rsa.pub(公钥)<br>当然你也可以输入不一样的文件名,比如github_one和github_two<br>配置完成后,输入一些命令查看你电脑上所有的</li></ul><h3 id="登录github添加公钥"><a href="#登录github添加公钥" class="headerlink" title="登录github添加公钥"></a>登录github添加公钥</h3><p>分别登录one,two的账号,在<code>Settings</code>-&gt;<code>SSH and GPG keys</code>点击<code>New SSH key</code>,把生成的公钥(.pub文件)内容粘贴到“Key”中,并输入“Title”.<br>可以在添加前使用下面命令删除所有的key<br><code>$ ssh-add -D</code></p><h3 id="修改ssh-config文件"><a href="#修改ssh-config文件" class="headerlink" title="修改ssh config文件"></a>修改ssh config文件</h3><p><code>$ cd ~/.ssh/</code><br><code>$ touch config</code><br><code>$ open config</code><br>然后在打开的config文件里面,输入以下内容</p><pre><code># oneHost one.github.comHostName github.comUser gitIdentityFile ~/.ssh/github_one# twoHost two.github.comHostName github.comUser gitIdentityFile ~/.ssh/github_two</code></pre><p>其中的Host默认的是github.com,但是可以任意写.如果不这样设置,push时会出现以下错误:<br><code>ERROR: Permission to two/two.github.com.git denied to one.</code><br>分析一下git提交时候的ssh链接,我们可以发现该链接实际上是由这样几个部分组成的:<br>git@Host:用户名/项目名.git,很明显,git是通过其中的Host来识别使用哪个本地私钥的。如果Host始终为github.com，那么就只能使用一个私钥,那么也就无法在使用ssh连接时区别不同的账号了.</p><h3 id="添加ssh-key"><a href="#添加ssh-key" class="headerlink" title="添加ssh key"></a>添加ssh key</h3><p>通过下面的命令,可以查看当前所有的key<br><code>$ ssh-add -l</code><br>如果发现刚才添加的key没有在列表中,可以使用以下指令进行添加<br><code>$ ssh-add -K ~/.ssh/github_one</code><br><code>$ ssh-add -K ~/.ssh/github_two</code><br>使用<code>-K</code>可以将私钥添加到钥匙串，不用每次开机后还要再次输入这条命令了</p><h3 id="连接测试"><a href="#连接测试" class="headerlink" title="连接测试"></a>连接测试</h3><p><code>$ ssh -T git@one.github.com        # 测试one ssh连接</code><br><code>$ ssh -T git@two.github.com        # 测试two ssh连接</code><br>如果分别出现以下结果,证明连接成功<br><code>#Hi one! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code><br><code>#Hi two! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code></p><h3 id="新建git项目或者clone已有项目"><a href="#新建git项目或者clone已有项目" class="headerlink" title="新建git项目或者clone已有项目"></a>新建git项目或者clone已有项目</h3><ul><li>可以用 git init 或者 git clone 创建本地项目</li><li><p>分别在one和two的git项目目录下，使用下面的命令设置账号关联</p><pre><code>git config user.name &quot;__name__&quot;            # __name__ 例如 onegit config user.email &quot;__email__&quot;          # __email__ 例如 one@163.com</code></pre><p>查看git项目的配置(在当前项目目录下)<br><code>$ git config --list</code><br>修改提交路径,比如在one的项目demo下</p><pre><code>git remote rm origingit remote add origin git@one.github.com:one/demo.git</code></pre><p>当然以上设置也可以不用命令行,直接在项目目录下<br><code>$ ls -a</code><br>你会发现在项目目录下有一个隐藏的.git文件夹,cd到这个文件夹,会发现里面有一个config文件<br>,打开该config文件,可以直接在里面修改远程路径,添加用户名和邮箱等</p><pre><code>$ cd .git$ open config</code></pre><p>完成后的效果如下图所示<br><img src="/img/2017/iOS/git_config.png" alt="config配置"><br>然后保存,退出即可</p></li></ul><h3 id="愉快的进行提交操作"><a href="#愉快的进行提交操作" class="headerlink" title="愉快的进行提交操作"></a>愉快的进行提交操作</h3><p>确保上面所有的设置都无误之后,就可以修改代码上传了</p><pre><code>git add -修改的文件git commit -m&quot;comments&quot;git push</code></pre><p>如果遇到warning</p><blockquote><p>warning: push.default is unset; its implicit value is changing in Git 2.0 from ‘matching’ to ‘simple’. To squelch this messageand maintain the current behavior after the default changes, use…</p></blockquote><p>推荐使用下面命令进行设置<br><code>$ git config --global push.default simple</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么-你还没有一个GitHub账号-😱&quot;&gt;&lt;a href=&quot;#什么-你还没有一个GitHub账号-😱&quot; class=&quot;headerlink&quot; title=&quot;什么,你还没有一个GitHub账号?😱&quot;&gt;&lt;/a&gt;什么,你还没有一个GitHub账号?😱&lt;/h3&gt;&lt;
      
    
    </summary>
    
      <category term="开发必备" scheme="http://blog.astudyer.com/categories/%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87/"/>
    
    
      <category term="Github" scheme="http://blog.astudyer.com/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>如何把自己写的框架上传至CocoaPods</title>
    <link href="http://blog.astudyer.com/%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87/%E7%BB%84%E4%BB%B6%E5%8C%96/%E5%A6%82%E4%BD%95%E6%8A%8A%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84%E6%A1%86%E6%9E%B6%E4%B8%8A%E4%BC%A0%E8%87%B3CocoaPods.html"/>
    <id>http://blog.astudyer.com/开发必备/组件化/如何把自己写的框架上传至CocoaPods.html</id>
    <published>2017-07-20T07:45:33.000Z</published>
    <updated>2020-09-14T01:44:08.315Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>作为一名iOS应用开发者，我们在实际工作中经常会用到各种各样的第三方库,比如我们常用的AFNetworking,SDWebimage等.这些类库一般都可以通过一款叫做Cocoapods的工具进行管理，非常的便利。当享受着Cocoapods带给我们的这种便利的同时，你是否想过让自己封装的常用的工具类也添加Cocoapods支持?本文将会一步步揭开CocoaPods的神秘面纱,教你把自己封装的一些工具类上传至CocoaPods,以后你就可以通过CocoaPods来使用自己封装的工具类了,听起来是不是很酷,那么就让我们开始我们的CocoaPods之旅吧.</p><h3 id="Cocoapods介绍"><a href="#Cocoapods介绍" class="headerlink" title="Cocoapods介绍"></a>Cocoapods介绍</h3><p>你来看这篇文章,我相信你肯定已经使用过CocoaPods了吧.就算没用过,起码也至少应该有所了解.<br>但是如果你并不了解CocoaPods是什么东西,以及如何使用,那么这里给你准备了一篇文章<a href="http://blog.devtang.com/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/" target="_blank" rel="noopener">用CocoaPods做iOS程序的依赖管理</a>,或者你也可以去自己百度,网上的教程一大堆,这里就不再对此进行相信的介绍了.</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>本文将会以我自己写的一个UI调试小工具<a href="https://github.com/hclib/UIHelper" target="_blank" rel="noopener">UIHelper</a>为例,来说明把自己写的类库上传至CocoaPods的整个过程.</p><ul><li>注册trunk</li><li>在github上上传相关的代码库</li><li>创建podspec配置文件</li><li>验证是否可用</li><li>推送到CocoaPods</li><li>检查是否可用</li></ul><h3 id="注册trunk"><a href="#注册trunk" class="headerlink" title="注册trunk"></a>注册trunk</h3><p>想让Cocoapods支持你自己的工具代码库，首先需要一个CocoaPods账号。<br>注册命令:<br><code>$ pod trunk register 邮箱地址 ‘用户名’ —description=&#39;描述信息&#39;</code><br>执行以上注册命令后，到你注册邮箱检查一下，一切顺利的话就会受到一份邮件，点击验证链接打开网页。如果出现下面的提示，说明注册成功(如果打开网页太慢的话，建议开vpn)。<br><img src="/img/2017/iOS/register_cocoapods.jpg" alt="注册成功的图示"><br>查看注册信息的命令:<br><code>$ pod trunk me</code><br><img src="/img/2017/iOS/cocoapods_trunk_me.jpg" alt="查看注册信息"></p><h3 id="在github上上传相关的代码库"><a href="#在github上上传相关的代码库" class="headerlink" title="在github上上传相关的代码库"></a>在github上上传相关的代码库</h3><p>到<a href="https://github.com/" target="_blank" rel="noopener">github官网</a>登录你的账户,执行Create a new repository操作,因为笔者已经创建过UIHelper这个项目,所有会有红色警告,如果你是第一次创建某个项目,不会有该警告.<br><img src="/img/2017/iOS/cocoapods_github.png" alt="在github上上传代码图示"><br>创建项目的时候请注意图中选择的MIT License选项,这个会在添加Cocoapods支持的时候用到.创建完成后,clone到本地,把你写的工具代码放到该文件夹,此时的目录结构如下图所示.<br><img src="/img/2017/iOS/cocoapods_mljg.png" alt="目录结构"></p><h3 id="创建podspec配置文件"><a href="#创建podspec配置文件" class="headerlink" title="创建podspec配置文件"></a>创建podspec配置文件</h3><p>打开终端，cd到刚刚的文件夹目录下，执行创建podspec命令：<br><code>$ pod spec create UIHelper</code><br>此时你会看到文件夹下多了一个UIHelper.podspec文件,如下图所示<br><img src="/img/2017/iOS/cocoapods_mljg2.jpg" alt="目录结构"><br>用vim或者Sublime Text或者其它文本编辑器打开该文件,会发现里面有很多内容,看起来可能毫无头绪,其实里面的很多内容是并没有用的,以下是我整理过后的内容(把不用的东西都删掉,只留下有用的),接下来就以此文件中的内容进行一下重点说明.<br><img src="/img/2017/iOS/cocoapods_podspec.png" alt="podspec文件"><br>当然，我们开发的库中也可能还依赖第三方库，例如SDWebimage，那么，就可以添加如下声明:<br><code>$ s.dependency &quot;SDWebimage&quot;, &quot;~&gt; 1.4&quot;</code><br>如果有多个需要填写多个s.dependency.</p><h3 id="验证是否可用"><a href="#验证是否可用" class="headerlink" title="验证是否可用"></a>验证是否可用</h3><ul><li>验证</li></ul><p>编辑完podspec文件后，需要验证一下这个文件是否可用，如果有WARNING或者ERROR是不可以的，就不能被添加到Spec Repo中，不过xcode的WARNING是可以存在的，进行验证的命令如下：<br><code>$ pod lib lint UIHelper.podspec</code><br>如果有没有Error输出，只有Warning输出，那么可以将这些警告直接忽略<br><code>$ pod lib lint UIHelper.podspec —allow-warnings</code><br>如果出现以下信息说明验证通过<br><img src="/img/2017/iOS/cocoapods_podspec_success.png" alt="验证通过"></p><ul><li>解决错误</li></ul><p>在验证podspec的时候，如果直接用pod spec lint xxx.podspec的话，出现错误它只会直接给出一句红色的提示The spec did not pass validation, due to 1 error.告诉你有多少个error和warning，而不会具体的指出你的错误出在哪里，这时候你可以在这句指令后面加上参数–verbose<br><code>$ pod lib lint UIHelper.podspec --verbose</code><br>这样就会告诉你具体的错误信息。然后就可以根据它提示的具体错误信息去解决问题了。**<br>在执行校验命令时如果出现类似<code>fatal error: &#39;UIKit/UIKit.h&#39; file not found</code>这样的错误，这里笔者提供2种解决方案,供大家参考。</p><ol><li>在podspec配置文件里，修改 s.framework选项如下<br><code>s.frameworks   = &quot;Foundation&quot;</code></li><li>在你的项目里，创建一个pch文件，将所有需要开源的代码库的.h头文件导入到pch文件里。<br>然后执行<code>$ pod lib lint UIHelper.podspec —allow-warnings</code>命令。</li></ol><ul><li>制作相应tag的版本</li></ul><p>所有错误都解决后，接下来我们需要将修改后的最新项目重新push到GitHub上(库文件 和 .spec文件)并制作一个和podspec文件里面对应的tag一致的release包,可以在github里面项目页点击release按照提示直接操作,如下图<br><img src="/img/2017/iOS/cocoapods_tag.jpg" alt="制作tag"><br>也可以使用以下命令直接操作<br><code>$ git tag &#39;1.0.3&#39;</code><br><code>$ git push --tags</code></p><h3 id="推送到CocoaPods"><a href="#推送到CocoaPods" class="headerlink" title="推送到CocoaPods"></a>推送到CocoaPods</h3><p>所有的准备工作都已经完成了，下面就可以将我们的项目push到Cocoapods.<br>执行命令：<code>$ pod trunk push UIHelper.podspec</code><br>如果出现如下图所示的结果,证明推送成功<br><img src="/img/2017/iOS/cocoppods_success.png" alt="推送成功"></p><h3 id="检查是否可用"><a href="#检查是否可用" class="headerlink" title="检查是否可用"></a>检查是否可用</h3><p>上传成功后,可以试一下能否通过pod search命令搜索到自己刚刚上传成功的类库<br><code>$ pod search UIHelper</code><br>如果搜索不到，建议删除本地的CocoaPods的搜索目录，执行以下命令：<br><code>$ rm ~/Library/Caches/CocoaPods/search_index.json</code><br>然后重新执行<code>$ pod search UIHelper</code>命令就可以了.<br>ps:如果你发布成功后，在你自己的电脑上可以search到，在别的电脑上搜不到，建议首先执行<code>$ rm ~/Library/Caches/CocoaPods/search_index.json</code>命令，先删除旧的搜索目录.也可以尝试更新你的pod.<br>最后完成的成果如下图所示<br><img src="/img/2017/iOS/cocoapods_result.png" alt="完成结果"></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>附上以上完成的小项目的github链接:<a href="https://github.com/hclib/UIHelper" target="_blank" rel="noopener">UIHelper</a>,你可以直接把UIHelper.podspec里面的内容复制粘贴到你项目中的.podspec文件里面,简单修改一下即可.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;作为一名iOS应用开发者，我们在实际工作中经常会用到各种各样的第三方库,比如我们常用的AFNetworking,SDWebimage等.这些
      
    
    </summary>
    
      <category term="开发必备" scheme="http://blog.astudyer.com/categories/%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87/"/>
    
    
      <category term="CocoaPods" scheme="http://blog.astudyer.com/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>如何把你的电脑配置成本地服务器</title>
    <link href="http://blog.astudyer.com/Server/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%A6%82%E4%BD%95%E6%8A%8A%E4%BD%A0%E7%9A%84%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE%E6%88%90%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8.html"/>
    <id>http://blog.astudyer.com/Server/服务器/如何把你的电脑配置成本地服务器.html</id>
    <published>2017-06-21T01:37:32.000Z</published>
    <updated>2020-09-14T01:44:08.314Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-曾经的苦恼"><a href="#1-曾经的苦恼" class="headerlink" title="1.曾经的苦恼"></a>1.曾经的苦恼</h3><p>很多搞过后台开发或者运维的同学对于服务器自然比较熟悉,但是很多做移动端开发,比如做iOS开发或者安卓开发的同学很多可能并不知道如何把自己的电脑设置成一台本地服务器.服务器的种类有很多,比如我们常见的Apache服务器,关于Apache的配制方法网上一搜一大堆,故本文不对此再加以讨论.<br>前一段学过一段时间PHP,当时按照网上的教程配置Apache,也踩了很多的坑,等有时间再整理.</p><h3 id="2-看到了希望"><a href="#2-看到了希望" class="headerlink" title="2.看到了希望"></a>2.看到了希望</h3><p>前几天突然在github上发现一个框架<a href="git@github.com:swisspol/GCDWebServer.git">GCDWebServer</a>,于是一切时间都变得简单了.这个框架使把你电脑上的某个文件夹变成服务端(可以在浏览器中通过IP地址和端口号访问,同时可以进行get和post请求)变得极为简单,这个就是本文所要讲的.另外该框架还有一个牛逼的功能就是可以在你进行iOS开发的时候在浏览器中访问你真机的沙盒,这个在我的另一篇文章中有详细的讲解,喜欢的小伙伴可以去看原文:<a href="http://127.0.0.1:4000/big-front-end/iOS-%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7-%E5%AE%9E%E6%97%B6%E8%AE%BF%E9%97%AE%E7%9C%9F%E6%9C%BA%E6%B2%99%E7%9B%92%E6%96%87%E4%BB%B6.html" target="_blank" rel="noopener">iOS 开发技巧 - 实时访问真机沙盒文件</a>.</p><h3 id="3-救赎之路"><a href="#3-救赎之路" class="headerlink" title="3.救赎之路"></a>3.救赎之路</h3><p>具体用法和<a href="http://127.0.0.1:4000/big-front-end/iOS-%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7-%E5%AE%9E%E6%97%B6%E8%AE%BF%E9%97%AE%E7%9C%9F%E6%9C%BA%E6%B2%99%E7%9B%92%E6%96%87%E4%BB%B6.html" target="_blank" rel="noopener">iOS 开发技巧 - 实时访问真机沙盒文件</a>中讲到的差不多,再次再简单说一下,不同的是这次要建一个MacOS项目.</p><ol><li>先建一个普通的MacOS命令行项目<br><img src="/img/2017/Server/GCD_local_server.jpg" alt="步骤1"></li><li>接下来在github上下载<a href="https://github.com/swisspol/GCDWebServer" target="_blank" rel="noopener">GCDWebServer</a>源码</li><li>把GCDWebServer和GCDWebUploader这两个文件夹拖到项目中<br><img src="/img/2017/Server/GCD_local_server_step3.jpg" alt="步骤3"></li><li>在Target &gt; Build Phases &gt; Link Binary With Libraries里面加入<code>libz.tbd</code>库</li><li>在Target &gt; Build Settings &gt; header_search_paths里面添加<code>$(SDKROOT)/usr/include/libxml2</code></li><li><p>终于到代码了,come on,baby,最后100米冲刺</p><pre><code>int main(int argc, const char * argv[]) {@autoreleasepool {    //1. 你想要设置为服务器的根目录    NSString *path = [NSString stringWithFormat:@&quot;%@/demo&quot;,NSHomeDirectory()];    //2. 初始化服务器    GCDWebServer *webServer = [[GCDWebServer alloc] init];    //3. indexFilename：服务器打开的index文件(首页)    [webServer addGETHandlerForBasePath:@&quot;/&quot; directoryPath:path indexFilename:@&quot;index.html&quot; cacheAge:3600 allowRangeRequests:YES];    //4. 启动服务器（port:端口号）    [webServer runWithPort:9190 bonjourName:@&quot;&quot;];}return 0;</code></pre><p> }</p></li><li>运行项目,如果没有意外,你会在控制台看到如下打印信息<br><img src="/img/2017/Server/GCD_local_server_result.jpg" alt="打印结果"></li><li>在浏览器中输入控制台打印的地址,你会看到如下界面<br><img src="/img/2017/Server/GCD_local_server_success.png" alt="运行结果"><blockquote><p>注意:</p><ol><li>看到此结果的前提是我已经提前在我想要设置为服务器根目录的那个文件夹下创建了一个index.html文件,内容是hello,world!</li><li>关闭服务器得方法也很简单,关闭项目那个地址就不可以访问了</li></ol></blockquote></li></ol><h3 id="恭喜你-成功了-以后你就可以通过这个地址访问你电脑里面设置好的文件夹了"><a href="#恭喜你-成功了-以后你就可以通过这个地址访问你电脑里面设置好的文件夹了" class="headerlink" title="!!!恭喜你,成功了,以后你就可以通过这个地址访问你电脑里面设置好的文件夹了"></a>!!!恭喜你,成功了,以后你就可以通过这个地址访问你电脑里面设置好的文件夹了</h3><h3 id="9-But-one-more-thing"><a href="#9-But-one-more-thing" class="headerlink" title="9.But one more thing"></a>9.But one more thing</h3><p>如果你感觉上面的方法还是麻烦,懒得配置,那么你可以用我利用此框架封装好的一款Mac软件,使用更为方便,需要的话请自行<a href="/img/2017/Server/MyServer.app.zip">下载</a>,以下是软件的效果图<br><img src="/img/2017/Server/myServer.png" alt="效果图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-曾经的苦恼&quot;&gt;&lt;a href=&quot;#1-曾经的苦恼&quot; class=&quot;headerlink&quot; title=&quot;1.曾经的苦恼&quot;&gt;&lt;/a&gt;1.曾经的苦恼&lt;/h3&gt;&lt;p&gt;很多搞过后台开发或者运维的同学对于服务器自然比较熟悉,但是很多做移动端开发,比如做iOS开发或者安卓
      
    
    </summary>
    
      <category term="Server" scheme="http://blog.astudyer.com/categories/Server/"/>
    
    
      <category term="GCDWebServer" scheme="http://blog.astudyer.com/tags/GCDWebServer/"/>
    
  </entry>
  
  <entry>
    <title>iOS 开发技巧 - 实时访问真机沙盒文件</title>
    <link href="http://blog.astudyer.com/iOS/iOS%E6%8A%80%E5%B7%A7/iOS-%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7-%E5%AE%9E%E6%97%B6%E8%AE%BF%E9%97%AE%E7%9C%9F%E6%9C%BA%E6%B2%99%E7%9B%92%E6%96%87%E4%BB%B6.html"/>
    <id>http://blog.astudyer.com/iOS/iOS技巧/iOS-开发技巧-实时访问真机沙盒文件.html</id>
    <published>2017-06-19T02:11:47.000Z</published>
    <updated>2020-09-14T01:44:08.313Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-想要解决的问题"><a href="#1-想要解决的问题" class="headerlink" title="1.想要解决的问题"></a>1.想要解决的问题</h3><blockquote><p>iOS开发过程中经常需要访问沙盒文件来调试持久化文件,数据库文件,缓存文件等.模拟器一般可以通过<br><a href="https://simpholders.com/" target="_blank" rel="noopener">SimPholders</a>或者<a href="https://github.com/dsmelov/simsim" target="_blank" rel="noopener">simsim</a>等来方便的访问沙盒.但是真机并没有一个方便快捷的访问修改方法,因此,很多时候,我们需要测试沙盒的时候不得不去使用模拟器来替代真机.那么有没有什么方法去直接<code>访问真机的沙盒</code>呢?</p></blockquote><h3 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2.解决方案"></a>2.解决方案</h3><p>说到访问真机沙盒,首先要给大家介绍一款框架<a href="https://github.com/swisspol/GCDWebServer" target="_blank" rel="noopener">GCDWebServer</a>,利用这款框架,你可以很方便的用<code>浏览器</code>实时的访问你真机的沙盒.</p><h3 id="3-集成方法"><a href="#3-集成方法" class="headerlink" title="3.集成方法"></a>3.集成方法</h3><p>方案一. 可以用过cocoapods集成<br>方案二. 可以用过手动集成</p><h3 id="4-集成步骤"><a href="#4-集成步骤" class="headerlink" title="4.集成步骤"></a>4.集成步骤</h3><p>由于笔者是通过手动集成的,这里着重介绍下<code>手动集成</code>方案,通过cocoapods集成方法大同小异,具体可以看官方文档</p><ol><li>首先在github上下载<a href="https://github.com/swisspol/GCDWebServer" target="_blank" rel="noopener">源码</a></li><li>然后把GCDWebServer和GCDWebUploader这两个文件夹拖到项目中<br><img src="/img/2017/iOS/skill_shahe_step2.jpg" alt="步骤2"></li><li>在Target &gt; Build Phases &gt; Link Binary With Libraries里面加入<code>libz.tbd</code>库</li><li>在Target &gt; Build Settings &gt; header_search_paths里面添加<code>$(SDKROOT)/usr/include/libxml2</code></li><li><p>在AppDelegate.m里面引入头文件</p><pre><code>#import &quot;HCViewController.h&quot;#import &quot;GCDWebUploader.h&quot;</code></pre></li><li><p>在AppDelegate.m的- (BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions方法中添加如下代码</p><pre><code>//1.想要访问的沙盒路径NSString *myDocPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;//2.初始化服务器_server = [[GCDWebUploader alloc] initWithUploadDirectory:myDocPath];//3.启动服务器(port代表端口号)[_server startWithPort:9090 bonjourName:@&quot;&quot;];//other code……</code></pre></li><li>运行项目,如果你在控制台看到如下信息,那么恭喜你,你已经成功了<br><img src="/img/2017/iOS/skill_shahe_result.jpg" alt="运行结果"></li><li>接下来只需要在浏览器中输入控制台打印出来的路径(输入IP那个)就可以在浏览器中访问你APP的沙盒了<br><img src="/img/2017/iOS/skill_shahe.png" alt="效果演示"></li></ol><h3 id="接下来尽情的享受你的沙盒之旅吧"><a href="#接下来尽情的享受你的沙盒之旅吧" class="headerlink" title="接下来尽情的享受你的沙盒之旅吧!"></a>接下来尽情的享受你的沙盒之旅吧!</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-想要解决的问题&quot;&gt;&lt;a href=&quot;#1-想要解决的问题&quot; class=&quot;headerlink&quot; title=&quot;1.想要解决的问题&quot;&gt;&lt;/a&gt;1.想要解决的问题&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;iOS开发过程中经常需要访问沙盒文件来调试持久化文件,数据
      
    
    </summary>
    
      <category term="iOS" scheme="http://blog.astudyer.com/categories/iOS/"/>
    
    
      <category term="沙盒" scheme="http://blog.astudyer.com/tags/%E6%B2%99%E7%9B%92/"/>
    
  </entry>
  
</feed>
